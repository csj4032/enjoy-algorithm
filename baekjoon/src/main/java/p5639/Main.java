package p5639;

import java.util.Scanner;

/**
 * 제목 : 이진 검색 트리
 * 링크 : https://www.acmicpc.net/problem/5639
 * 분류 : 트리, 이진 검색 트리, 재귀, 분할 정복
 * 
 * === 문제 해설 ===
 * 이진 검색 트리의 전위 순회 결과가 주어졌을 때 후위 순회 결과를 구하는 문제입니다.
 * 이진 검색 트리의 특성과 트리 순회 알고리즘을 종합적으로 이해해야 하는 문제입니다.
 * 
 * === 수학적/이론적 배경 ===
 * 1) 이진 검색 트리(BST)의 정의:
 *    - 각 노드의 왼쪽 서브트리 < 노드 < 오른쪽 서브트리
 *    - 중위 순회시 정렬된 순서로 방문됨
 *    - 탐색, 삽입, 삭제 연산이 평균 O(log N)
 * 
 * 2) 트리 순회의 특성:
 *    - 전위 순회: 루트 → 왼쪽 → 오른쪽
 *    - 중위 순회: 왼쪽 → 루트 → 오른쪽  
 *    - 후위 순회: 왼쪽 → 오른쪽 → 루트
 *    - BST에서 중위 순회 = 정렬된 순서
 * 
 * 3) 트리 복원의 이론:
 *    - 전위 + 중위 → 유일한 트리 복원 가능
 *    - BST에서는 전위 순회만으로도 복원 가능
 *    - 정렬된 중위 순회 결과를 암시적으로 알 수 있음
 * 
 * === 알고리즘 설계 ===
 * 1) 재귀적 분할 정복:
 *    - 전위 순회의 첫 번째 원소 = 루트
 *    - BST 성질을 이용하여 왼쪽/오른쪽 서브트리 분할
 *    - 각 서브트리에 대해 재귀적으로 후위 순회
 * 
 * 2) 분할 지점 찾기:
 *    - 루트보다 큰 첫 번째 원소를 찾음
 *    - 그 지점이 오른쪽 서브트리의 시작점
 *    - 이진 탐색으로 O(log N)에 찾기 가능
 * 
 * 3) 후위 순회 생성:
 *    - 왼쪽 서브트리 후위 순회
 *    - 오른쪽 서브트리 후위 순회
 *    - 루트 노드 출력
 * 
 * === 구현 세부사항 ===
 * 1) 입력 처리:
 *    - EOF까지 읽어야 함 (정확한 개수 주어지지 않음)
 *    - hasNextInt() 또는 try-catch로 처리
 *    - ArrayList에 동적으로 저장
 * 
 * 2) 재귀 함수 구현:
 *    - postOrder(start, end): 범위 내에서 후위 순회
 *    - BST 성질을 이용한 효율적 분할
 *    - 기저 조건: start > end
 * 
 * 3) 분할 지점 탐색:
 *    - 선형 탐색: O(N) - 간단한 구현
 *    - 이진 탐색: O(log N) - 최적화된 구현
 *    - BST 성질 활용하여 정확한 분할점 찾기
 * 
 * === 시간/공간 복잡도 ===
 * - 시간복잡도: O(N²) (최악) ~ O(N log N) (평균)
 * - 공간복잡도: O(N) (입력 저장) + O(H) (재귀 스택)
 * - H: 트리의 높이 (균형: log N, 편향: N)
 * 
 * === 고급 최적화 기법 ===
 * 1) 이진 탐색 활용:
 *    - 분할 지점을 O(log N)에 찾기
 *    - Collections.binarySearch() 활용
 *    - 전체 시간복잡도를 O(N log N)으로 개선
 * 
 * 2) 스택 기반 구현:
 *    - 재귀 대신 명시적 스택 사용
 *    - 스택 오버플로우 방지
 *    - 메모리 사용 패턴 최적화
 * 
 * 3) 인덱스 기반 처리:
 *    - 배열 복사 없이 인덱스만 전달
 *    - 메모리 할당 오버헤드 제거
 *    - 캐시 지역성 향상
 * 
 * === 대안 해결법 ===
 * 1) 트리 구조 직접 구성:
 *    - Node 클래스로 실제 트리 구성
 *    - 전위 순회로 BST 삽입 수행
 *    - 구성된 트리에서 후위 순회
 * 
 * 2) 스택 시뮬레이션:
 *    - 스택을 이용한 후위 순회 시뮬레이션
 *    - 전위 순회 결과를 역으로 처리
 *    - 메모리 효율적이지만 복잡한 로직
 * 
 * 3) 수학적 접근:
 *    - BST의 형태를 수학적으로 분석
 *    - 카탈란 수와의 관계 활용
 *    - 이론적으로 흥미롭지만 실용성 낮음
 * 
 * === 실전 코딩테스트 대비 포인트 ===
 * 1) EOF 처리:
 *    - hasNextInt() 사용
 *    - try-catch로 NumberFormatException 처리  
 *    - Scanner.hasNext() 활용
 * 
 * 2) BST 성질 활용:
 *    - 루트를 기준으로 한 분할
 *    - 정렬된 중위 순회의 암시적 활용
 *    - 불필요한 트리 구성 피하기
 * 
 * 3) 재귀 구현 주의사항:
 *    - 기저 조건 명확히 설정
 *    - 인덱스 범위 체크
 *    - 스택 오버플로우 고려
 * 
 * === BST 관련 심화 내용 ===
 * 1) 균형 BST:
 *    - AVL 트리: 높이 균형 보장
 *    - Red-Black 트리: 색깔 기반 균형
 *    - Splay 트리: 자가 조정 트리
 * 
 * 2) BST 연산들:
 *    - 삽입: O(log N) 평균, O(N) 최악
 *    - 삭제: successor/predecessor 활용
 *    - 탐색: 이진 탐색과 동일한 원리
 * 
 * 3) BST 변형들:
 *    - 확률적 BST (Treap)
 *    - B-트리 (다진 탐색 트리)
 *    - Trie (문자열 전용 트리)
 * 
 * === 관련 알고리즘 패러다임 ===
 * 1) 분할 정복:
 *    - 문제를 작은 부분으로 분할
 *    - 각 부분을 독립적으로 해결
 *    - 결과를 합성하여 전체 해답 구성
 * 
 * 2) 재귀적 사고:
 *    - 자기 자신을 포함하는 정의
 *    - 기저 조건과 점화식
 *    - 스택 프레임의 이해
 * 
 * 3) 트리 알고리즘:
 *    - 트리 순회의 다양한 방법
 *    - 부모-자식 관계 활용
 *    - 서브트리의 독립성
 * 
 * === 실제 응용 사례 ===
 * 1) 데이터베이스:
 *    - B+ 트리 인덱스
 *    - 범위 쿼리 최적화
 *    - 정렬된 데이터 접근
 * 
 * 2) 파일 시스템:
 *    - 디렉토리 구조 관리
 *    - 파일명 정렬 및 검색
 *    - 계층적 네임스페이스
 * 
 * 3) 컴파일러:
 *    - 심볼 테이블 관리
 *    - 추상 구문 트리 (AST)
 *    - 스코프 관리
 * 
 * === 확장 문제들 ===
 * 1) 다양한 순회 조합에서 트리 복원
 * 2) 균형 BST로 변환
 * 3) BST에서 k번째 작은 원소 찾기
 * 4) 두 BST의 합집합/교집합
 * 5) BST를 연결 리스트로 변환
 * 
 * === 트리 순회의 응용 ===
 * 1) 수식 트리:
 *    - 전위: 접두 표기법
 *    - 중위: 중위 표기법 (괄호 필요)
 *    - 후위: 후위 표기법 (스택 계산)
 * 
 * 2) 파싱 트리:
 *    - 구문 분석 결과 표현
 *    - 의미 분석 단계 준비
 *    - 코드 생성 최적화
 * 
 * 3) 결정 트리:
 *    - 기계학습 모델
 *    - 분류 및 회귀 문제
 *    - 특성 중요도 분석
 */
public class Main {
    
    static int[] preorder;
    static int index = 0;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // EOF까지 입력 읽기
        java.util.List<Integer> input = new java.util.ArrayList<>();
        while (sc.hasNextInt()) {
            input.add(sc.nextInt());
        }
        
        // 배열로 변환
        preorder = input.stream().mapToInt(i -> i).toArray();
        
        // 후위 순회 수행
        postOrder(0, preorder.length - 1);
    }
    
    /**
     * 주어진 범위에서 BST의 후위 순회를 수행
     * 
     * @param start 시작 인덱스
     * @param end 끝 인덱스
     */
    static void postOrder(int start, int end) {
        if (start > end) {
            return;
        }
        
        int root = preorder[start];
        int rightStart = start + 1;
        
        // 오른쪽 서브트리의 시작점 찾기
        // BST 성질: 루트보다 큰 첫 번째 원소
        while (rightStart <= end && preorder[rightStart] < root) {
            rightStart++;
        }
        
        // 왼쪽 서브트리 후위 순회 (start+1 ~ rightStart-1)
        postOrder(start + 1, rightStart - 1);
        
        // 오른쪽 서브트리 후위 순회 (rightStart ~ end)
        postOrder(rightStart, end);
        
        // 루트 출력 (후위 순회의 마지막)
        System.out.println(root);
    }
}