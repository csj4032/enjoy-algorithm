package p1916;

import java.util.*;

/**
 * 제목 : 최소비용 구하기 - Dijkstra's Shortest Path Algorithm
 * 링크 : https://www.acmicpc.net/problem/1916
 * 분류 : 그래프 이론, 최단 경로, 다익스트라
 * 난이도 : Gold V
 * 
 * ========================================================================
 * ■ 문제 개요 및 핵심 개념
 * ========================================================================
 * 
 * n개의 도시와 m개의 버스 노선이 주어질 때, A 도시에서 B 도시로 가는 
 * 최소 비용을 구하는 전형적인 단일 출발점 최단 경로 문제입니다.
 * 
 * ★ 핵심 개념:
 * - 가중치가 있는 방향 그래프에서의 최단 경로
 * - 음수 가중치가 없는 조건 (다익스트라 알고리즘 적용 가능)
 * - 단일 출발점에서 특정 목적지까지의 최단 거리
 * 
 * ★ 입력 조건:
 * - 1 ≤ n ≤ 1,000 (도시의 개수)
 * - 1 ≤ m ≤ 100,000 (버스의 개수)
 * - 1 ≤ 비용 ≤ 100,000 (음수 가중치 없음)
 * 
 * ========================================================================
 * ■ 다익스트라 알고리즘의 수학적 원리와 이론적 배경
 * ========================================================================
 * 
 * ★ 1. 기본 원리 (Edsger W. Dijkstra, 1956)
 * 
 * 다익스트라 알고리즘은 "그리디 선택 속성"과 "최적 부분 구조"를 기반으로 합니다.
 * 
 * 핵심 아이디어:
 * - 출발점에서 각 정점까지의 최단 거리를 점진적으로 확정
 * - 현재까지 알려진 최단 거리 중 가장 짧은 거리의 정점을 선택
 * - 선택된 정점을 통해 다른 정점들의 거리를 갱신
 * 
 * ★ 2. 수학적 정당성 증명
 * 
 * 정리: 음수 가중치가 없는 그래프에서 다익스트라 알고리즘은 항상 최적해를 찾는다.
 * 
 * 증명 (귀납법):
 * 1) 기저 사례: 출발점의 거리는 0으로 올바름
 * 2) 귀납 가정: k번째까지 선택된 정점들의 거리가 모두 최적
 * 3) 귀납 단계: (k+1)번째 선택된 정점 v의 거리도 최적임을 증명
 * 
 * 반증을 통한 증명:
 * - v까지의 더 짧은 경로가 존재한다고 가정
 * - 그 경로는 아직 방문하지 않은 정점 u를 거쳐야 함
 * - 하지만 d[u] ≥ d[v] (우선순위 큐의 성질)
 * - 음수 가중치가 없으므로 u를 거치는 경로는 더 길 수밖에 없음
 * - 모순이므로 v의 거리는 최적
 * 
 * ★ 3. 알고리즘의 불변조건 (Loop Invariant)
 * 
 * 매 반복마다 유지되는 조건:
 * 1) S (방문한 정점 집합)에 속한 모든 정점의 거리는 최적
 * 2) 우선순위 큐에는 아직 확정되지 않은 정점들이 현재 알려진 최단 거리 순으로 저장
 * 3) dist[v] = 출발점에서 v까지의 현재 알려진 최단 거리
 * 
 * ========================================================================
 * ■ 구현 방법과 자료구조 선택
 * ========================================================================
 * 
 * ★ 1. 기본 구현 방법들
 * 
 * 방법 1) 배열 기반 (O(V²) 구현):
 * - 거리 배열과 방문 배열 사용
 * - 매번 최소 거리 정점을 선형 탐색
 * - 밀집 그래프에서 효율적
 * 
 * 방법 2) 우선순위 큐 기반 (O((V+E)logV) 구현):
 * - 힙을 이용한 우선순위 큐 사용
 * - 최소 거리 정점을 O(logV) 시간에 추출
 * - 희소 그래프에서 효율적 (일반적으로 더 빠름)
 * 
 * ★ 2. 우선순위 큐 구현 상세
 * 
 * Java에서 PriorityQueue 사용 시 주의점:
 * - 기본적으로 최소힙 구조
 * - Comparator를 통한 정렬 기준 설정
 * - Node 클래스에 거리와 정점 번호 저장
 * 
 * ★ 3. 그래프 표현 방법
 * 
 * 인접 리스트를 사용하는 이유:
 * - 공간 복잡도: O(V+E) vs 인접 행렬의 O(V²)
 * - 희소 그래프에서 메모리 효율적
 * - 정점의 인접 정점들만 순회하므로 시간 효율적
 * 
 * ========================================================================
 * ■ 시간/공간 복잡도 상세 분석
 * ========================================================================
 * 
 * ★ 우선순위 큐 기반 구현의 복잡도
 * 
 * 시간 복잡도: O((V + E) log V)
 * - 각 정점은 최대 한 번 큐에서 추출: O(V log V)
 * - 각 간선은 최대 한 번 완화 연산: O(E log V)
 * - 총 시간 복잡도: O((V + E) log V)
 * 
 * 공간 복잡도: O(V + E)
 * - 인접 리스트: O(V + E)
 * - 거리 배열: O(V)
 * - 우선순위 큐: O(V) (최악의 경우)
 * 
 * ★ 실제 성능 특성
 * 
 * - 이론적 복잡도 vs 실제 성능:
 *   * 대부분의 정점이 여러 번 큐에 들어가지 않음
 *   * 조기 종료 가능 (목표 정점 도달 시)
 *   * 메모리 지역성이 좋음
 * 
 * - 그래프 특성에 따른 성능:
 *   * 밀집 그래프 (E ≈ V²): 배열 기반이 더 효율적일 수 있음
 *   * 희소 그래프 (E ≪ V²): 우선순위 큐 기반이 항상 우수
 * 
 * ========================================================================
 * ■ 다른 최단 경로 알고리즘과의 비교
 * ========================================================================
 * 
 * ★ 1. Dijkstra vs Bellman-Ford
 * 
 * Dijkstra:
 * - 음수 가중치 불가
 * - 시간 복잡도: O((V+E)logV)
 * - 그리디 알고리즘
 * - 단일 출발점 최단 경로
 * 
 * Bellman-Ford:
 * - 음수 가중치 허용
 * - 음수 사이클 탐지 가능
 * - 시간 복잡도: O(VE)
 * - 동적 계획법
 * 
 * ★ 2. Dijkstra vs Floyd-Warshall
 * 
 * Dijkstra:
 * - 단일 출발점
 * - O((V+E)logV)
 * - 희소 그래프에 적합
 * 
 * Floyd-Warshall:
 * - 모든 쌍 최단 경로
 * - O(V³)
 * - 밀집 그래프에 적합
 * - 음수 가중치 허용
 * 
 * ★ 3. A* 알고리즘과의 관계
 * 
 * A*는 다익스트라의 확장:
 * - 휴리스틱 함수 h(n) 추가
 * - f(n) = g(n) + h(n) (실제비용 + 추정비용)
 * - 목표 지향적 탐색으로 더 빠른 수행
 * - 게임 AI, 로봇 경로 계획에 활용
 * 
 * ========================================================================
 * ■ 실전 코딩테스트 대비 포인트
 * ========================================================================
 * 
 * ★ 1. 구현 시 주의사항
 * 
 * 1) 무한대 값 설정:
 *    - Integer.MAX_VALUE 사용 시 오버플로우 주의
 *    - 충분히 큰 값으로 설정 (예: 1e9)
 * 
 * 2) 우선순위 큐 사용법:
 *    - 거리가 갱신되어도 큐에서 제거되지 않음
 *    - 중복 방문 방지를 위한 visited 배열 필요
 * 
 * 3) 그래프 입력 처리:
 *    - 1-based vs 0-based 인덱싱 주의
 *    - 중복 간선, 자기 자신으로의 간선 처리
 * 
 * ★ 2. 최적화 기법
 * 
 * 1) 조기 종료:
 *    - 목표 정점에 도달하면 즉시 종료
 *    - 단일 목적지 쿼리에서 효과적
 * 
 * 2) 양방향 탐색:
 *    - 출발점과 도착점에서 동시에 탐색
 *    - 만나는 지점에서 종료
 *    - 대용량 그래프에서 효과적
 * 
 * ★ 3. 메모리 사용량 최적화
 * 
 * 1) 인접 리스트 구현:
 *    - ArrayList vs LinkedList 선택
 *    - 메모리 사용량과 접근 시간 트레이드오프
 * 
 * 2) 불필요한 객체 생성 방지:
 *    - Node 객체의 재사용
 *    - Primitive wrapper 클래스 사용 최소화
 * 
 * ========================================================================
 * ■ 확장 문제와 응용 사례
 * ========================================================================
 * 
 * ★ 1. 실무 응용 분야
 * 
 * 1) 네트워크 라우팅:
 *    - 인터넷 프로토콜의 라우팅 테이블 구성
 *    - OSPF(Open Shortest Path First) 프로토콜
 * 
 * 2) 지도 서비스:
 *    - 네비게이션 시스템의 최단 경로 탐색
 *    - 실시간 교통 상황을 반영한 경로 계산
 * 
 * 3) 게임 개발:
 *    - NPC의 최적 이동 경로 계산
 *    - 전략 게임의 유닛 이동
 * 
 * 4) 소셜 네트워크:
 *    - 6도 분리 이론 검증
 *    - 영향력 전파 경로 분석
 * 
 * ★ 2. 관련 심화 문제
 * 
 * - BOJ 1753: 최단경로 (다익스트라 기본)
 * - BOJ 1504: 특정한 최단경로 (경유지 있는 최단경로)
 * - BOJ 4485: 녹색 옷 입은 애가 젤다지? (2D 그리드 다익스트라)
 * - BOJ 1238: 파티 (왕복 최단경로)
 * - BOJ 5972: 택배 배송 (다익스트라 응용)
 * 
 * ★ 3. 고급 변형 문제
 * 
 * 1) K번째 최단경로:
 *    - Yen's algorithm
 *    - 우선순위 큐에서 K번 추출
 * 
 * 2) 시간 의존적 최단경로:
 *    - 시간에 따라 가중치가 변하는 경우
 *    - 동적 다익스트라 알고리즘
 * 
 * 3) 제약 조건이 있는 최단경로:
 *    - 특정 정점을 지나야 하거나 지나면 안 되는 경우
 *    - 상태 공간 확장을 통한 해결
 * 
 * ========================================================================
 * ■ 구현 상세 분석
 * ========================================================================
 * 
 * 현재 구현의 특징:
 * 1) 우선순위 큐 기반의 표준적인 다익스트라 구현
 * 2) 인접 리스트를 이용한 그래프 표현
 * 3) Node 클래스를 통한 간선 정보 캡슐화
 * 4) 중복 방문 방지를 위한 visited 배열 사용
 * 
 * 최적화 가능한 점:
 * 1) 조기 종료 조건 추가
 * 2) 메모리 사용량 최적화
 * 3) 입력 검증 및 예외 처리 강화
 */
public class Main {
    
    static class Node implements Comparable<Node> {
        int vertex;
        int cost;
        
        public Node(int vertex, int cost) {
            this.vertex = vertex;
            this.cost = cost;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.cost, other.cost);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt(); // 도시의 개수
        int m = sc.nextInt(); // 버스의 개수
        
        // 인접 리스트로 그래프 표현
        List<List<Node>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        // 간선 정보 입력
        for (int i = 0; i < m; i++) {
            int from = sc.nextInt();
            int to = sc.nextInt();
            int cost = sc.nextInt();
            graph.get(from).add(new Node(to, cost));
        }
        
        int start = sc.nextInt(); // 출발 도시
        int end = sc.nextInt();   // 도착 도시
        
        // 다익스트라 알고리즘 실행
        int result = dijkstra(graph, n, start, end);
        System.out.println(result);
    }
    
    /**
     * 다익스트라 알고리즘을 이용한 최단 경로 탐색
     * 
     * @param graph 인접 리스트로 표현된 그래프
     * @param n 정점의 개수
     * @param start 출발 정점
     * @param end 도착 정점
     * @return 최단 거리
     */
    private static int dijkstra(List<List<Node>> graph, int n, int start, int end) {
        // 최단 거리 배열 초기화
        int[] dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;
        
        // 방문 여부 배열
        boolean[] visited = new boolean[n + 1];
        
        // 우선순위 큐 (최소힙)
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int currentVertex = current.vertex;
            int currentCost = current.cost;
            
            // 이미 방문한 정점이면 건너뛰기
            if (visited[currentVertex]) {
                continue;
            }
            
            visited[currentVertex] = true;
            
            // 목표 정점에 도달하면 조기 종료 (최적화)
            if (currentVertex == end) {
                return currentCost;
            }
            
            // 인접한 정점들에 대해 거리 갱신
            for (Node neighbor : graph.get(currentVertex)) {
                int nextVertex = neighbor.vertex;
                int nextCost = currentCost + neighbor.cost;
                
                // 더 짧은 경로를 발견한 경우
                if (!visited[nextVertex] && nextCost < dist[nextVertex]) {
                    dist[nextVertex] = nextCost;
                    pq.offer(new Node(nextVertex, nextCost));
                }
            }
        }
        
        return dist[end];
    }
}