package p11727;

/*
 * 백준 11727번: 2×n 타일링 2
 * https://www.acmicpc.net/problem/11727
 * 
 * [문제 분류] 동적 계획법(DP) / 수학
 * [난이도] Silver 3
 * 
 * [문제 요약]
 * 2×n 크기의 직사각형을 다음 타일들로 채우는 방법의 수를 구하시오.
 * - 1×2 타일 (가로 타일)
 * - 2×1 타일 (세로 타일)  
 * - 2×2 타일 (정사각형 타일) ← 11726번과의 차이점
 * 
 * [제약 조건]
 * - 1 ≤ n ≤ 1,000
 * - 답을 10,007로 나눈 나머지 출력
 * 
 * [11726번과의 차이점]
 * 11726번 (2×n 타일링):
 * - 1×2, 2×1 타일만 사용
 * - 점화식: f(n) = f(n-1) + f(n-2)
 * - 피보나치 수열과 동일
 * 
 * 11727번 (2×n 타일링 2):
 * - 1×2, 2×1, 2×2 타일 사용  
 * - 점화식: f(n) = f(n-1) + 2×f(n-2)
 * - 2×2 타일로 인한 계수 변화
 * 
 * [알고리즘 설명 - DP 점화식 도출]
 * 1. 마지막 열을 기준으로 경우 분석:
 *    
 *    Case 1: 맨 끝에 2×1 타일 1개
 *    [     ][■]
 *    [     ][■] → f(n-1)가지
 *    
 *    Case 2: 맨 끝에 1×2 타일 2개 (위아래로)
 *    [     ][■■]
 *    [     ][■■] → f(n-2)가지
 *    
 *    Case 3: 맨 끝에 2×2 타일 1개
 *    [     ][■■]
 *    [     ][■■] → f(n-2)가지
 * 
 * 2. 점화식 도출:
 *    f(n) = f(n-1) + f(n-2) + f(n-2)
 *    f(n) = f(n-1) + 2×f(n-2)
 * 
 * [초기값 설정]
 * - f(1) = 1: 2×1 타일 1개만 놓는 방법
 * - f(2) = 3: 
 *   1) 2×1 타일 2개
 *   2) 1×2 타일 2개 (위아래)
 *   3) 2×2 타일 1개
 * 
 * [점화식 검증]
 * f(3) = f(2) + 2×f(1) = 3 + 2×1 = 5
 * 실제 f(3) = 5가지:
 * 1) [■][■][■] (2×1 타일 3개)
 * 2) [■][■■] (2×1 + 1×2×2)  
 * 3) [■■][■] (1×2×2 + 2×1)
 * 4) [■■■■] (1×2 타일 3쌍)
 * 5) [■■][■■] (2×2 + 1×2×2)
 * 
 * [구현 최적화]
 * 1. 공간 최적화:
 *    int prev2 = 1, prev1 = 3, current;
 *    for (int i = 3; i <= n; i++) {
 *        current = (prev1 + 2 * prev2) % 10007;
 *        prev2 = prev1;
 *        prev1 = current;
 *    }
 * 
 * 2. 모듈러 연산:
 *    - 오버플로우 방지를 위해 10007로 나눈 나머지
 *    - (a + b) % m = ((a % m) + (b % m)) % m
 * 
 * [일반화된 패턴]
 * 2×n 타일링 문제들의 일반적 패턴:
 * - 사용할 수 있는 타일의 종류에 따라 점화식 결정
 * - 마지막 부분을 어떻게 채울지에 따른 경우 분석
 * - 대부분 선형 점화식으로 귀결
 * 
 * [코딩테스트 관점]
 * - DP 기본 문제 중 점화식 도출 연습용
 * - 경우의 수 계산 문제의 전형
 * - 모듈러 연산 처리 능력 확인
 * - 점화식 도출 논리적 사고력 검증
 * 
 * [관련 문제들]
 * - 2×n 타일링 (11726번) - 기본 버전
 * - 타일 채우기 (2133번) - 3×n 버전 (더 복잡)
 * - 피보나치 함수 (1003번) - 점화식 기초
 * - 01타일 (1904번) - 다른 형태의 타일링
 * 
 * [실제 응용]
 * - 조합론적 계수 문제
 * - 격자 경로 계산
 * - 순열과 조합의 변형 문제
 * - 확률 계산에서의 경우의 수
 * 
 * [수학적 배경]
 * - 선형 점화식 이론
 * - 조합론 (Combinatorics)
 * - 생성함수 (Generating Function)
 * 
 * [시간복잡도] O(n) - 선형 시간
 * [공간복잡도] O(n) - DP 배열 (O(1)로 최적화 가능)
 */

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] m = new int[1001];

		m[1] = 1;
		m[2] = 3;

		for (int i = 3; i <= n; i++) {
			m[i] = (m[i - 1] + m[i - 2] * 2) % 10007;
		}
		System.out.println(m[n]);
	}
}