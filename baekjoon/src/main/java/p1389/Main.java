package p1389;

import java.util.Scanner;

/**
 * 제목 : 케빈 베이컨의 6단계 법칙
 * 링크 : https://www.acmicpc.net/problem/1389
 * 분류 : 최단경로, 플로이드 워셜, 그래프, BFS
 * 
 * === 문제 해설 ===
 * 각 사람의 케빈 베이컨 수(다른 모든 사람과의 거리 합)를 구하고,
 * 가장 작은 케빈 베이컨 수를 가진 사람을 찾는 문제입니다.
 * 
 * === 케빈 베이컨의 6단계 법칙 배경 ===
 * 1) 사회적 네트워크 이론:
 *    - 임의의 두 사람은 최대 6단계로 연결됨
 *    - 작은 세상 현상(Small World Phenomenon)
 *    - 소셜 네트워크의 수학적 모델링
 * 
 * 2) 그래프 이론적 해석:
 *    - 정점: 사람
 *    - 간선: 직접적인 관계 (친구 관계)
 *    - 가중치 없는 무향 그래프
 *    - 거리 = 최단 경로의 간선 수
 * 
 * 3) 케빈 베이컨 수:
 *    - 한 사람에서 다른 모든 사람까지의 거리 합
 *    - 중심성(Centrality) 지표 중 하나
 *    - 작을수록 네트워크의 중심에 위치
 * 
 * === 수학적/이론적 배경 ===
 * 1) 그래프 중심성 측정:
 *    - 근접 중심성(Closeness Centrality)의 변형
 *    - 중개 중심성(Betweenness Centrality)과 관련
 *    - 네트워크 분석의 핵심 지표
 * 
 * 2) 최단경로 문제의 특수 케이스:
 *    - 모든 간선의 가중치가 1
 *    - 무향 그래프 (양방향 연결)
 *    - 모든 정점 쌍 간의 최단 거리 필요
 * 
 * 3) 알고리즘 선택 고려사항:
 *    - 작은 그래프 크기 (N ≤ 100)
 *    - 모든 쌍의 거리 필요
 *    - 플로이드 워셜 vs 다중 BFS
 * 
 * === 알고리즘 설계 ===
 * 1) 플로이드 워셜 접근법:
 *    - 장점: 구현 간단, 모든 쌍 거리 한 번에 계산
 *    - 시간복잡도: O(N³)
 *    - 작은 N에서 효율적
 * 
 * 2) 다중 BFS 접근법:
 *    - 각 정점에서 BFS 수행
 *    - 시간복잡도: O(N × (N + M))
 *    - 희소 그래프에서 유리
 * 
 * 3) 구현 선택:
 *    - N이 작으므로 플로이드 워셜 권장
 *    - 코드 간결성과 정확성 우선
 * 
 * === 구현 세부사항 ===
 * 1) 거리 배열 초기화:
 *    - dist[i][i] = 0 (자기 자신)
 *    - dist[i][j] = INF (연결되지 않음)
 *    - 직접 연결된 경우 = 1
 * 
 * 2) 플로이드 워셜 적용:
 *    - 가중치가 모두 1이므로 간단
 *    - 3중 반복문으로 모든 경유 경로 확인
 *    - 최소값 갱신
 * 
 * 3) 케빈 베이컨 수 계산:
 *    - 각 사람별로 다른 모든 사람과의 거리 합
 *    - 최소값과 해당 사람 번호 추적
 * 
 * === 시간/공간 복잡도 ===
 * - 시간복잡도: O(N³) - 플로이드 워셜
 * - 공간복잡도: O(N²) - 거리 배열
 * - N ≤ 100이므로 충분히 빠름
 * 
 * === 대안 해결법 비교 ===
 * 1) 플로이드 워셜:
 *    - 시간: O(N³)
 *    - 공간: O(N²)
 *    - 구현: 간단
 *    - 적합성: 작은 그래프에 최적
 * 
 * 2) 다중 BFS:
 *    - 시간: O(N × (N + M))
 *    - 공간: O(N + M)
 *    - 구현: 중간
 *    - 적합성: 희소 그래프에 유리
 * 
 * 3) 다중 다익스트라:
 *    - 불필요한 오버헤드 (가중치가 1)
 *    - BFS가 더 효율적
 * 
 * === 고급 최적화 기법 ===
 * 1) 조기 종료:
 *    - 현재 최소값보다 합이 커지면 중단
 *    - 계산 중간에 pruning 적용
 * 
 * 2) 대칭성 활용:
 *    - 무향 그래프의 대칭성 이용
 *    - 계산량을 절반으로 줄일 수 있음
 * 
 * 3) 비트마스크 활용:
 *    - 방문 체크를 비트 연산으로
 *    - 메모리 접근 최적화
 * 
 * === 실전 코딩테스트 대비 포인트 ===
 * 1) 문제 해석:
 *    - "케빈 베이컨 수"의 정의 명확히 이해
 *    - 거리 합의 최소값을 가진 사람 찾기
 *    - 동점인 경우 번호가 작은 사람
 * 
 * 2) 구현 주의사항:
 *    - 무향 그래프이므로 양방향 간선 추가
 *    - INF 값 적절히 설정
 *    - 자기 자신과의 거리는 0
 * 
 * 3) 테스트 케이스:
 *    - 완전 그래프: 모든 거리가 1
 *    - 체인 그래프: 중앙이 최적
 *    - 스타 그래프: 중심 노드가 최적
 * 
 * === 네트워크 분석 관점 ===
 * 1) 중심성 지표:
 *    - 근접 중심성: 1/케빈베이컨수
 *    - 매개 중심성: 최단경로를 지나는 횟수
 *    - 고유벡터 중심성: 영향력 있는 노드와의 연결
 * 
 * 2) 소셜 네트워크 특성:
 *    - 작은 세상 네트워크
 *    - 척도 없는 네트워크 (Scale-free)
 *    - 클러스터링 계수
 * 
 * 3) 실제 응용:
 *    - 소셜 미디어 인플루언서 발견
 *    - 정보 전파 경로 분석
 *    - 바이럴 마케팅 전략
 * 
 * === 관련 알고리즘 패러다임 ===
 * 1) 최단경로 알고리즘:
 *    - BFS (가중치 없는 그래프)
 *    - 다익스트라 (가중치 있는 그래프)
 *    - 플로이드 워셜 (모든 쌍)
 * 
 * 2) 그래프 탐색:
 *    - DFS: 깊이 우선 탐색
 *    - BFS: 너비 우선 탐색
 *    - 양방향 BFS: 효율성 개선
 * 
 * 3) 동적 계획법:
 *    - 최적 부분구조
 *    - 중복 부분문제
 *    - 메모이제이션
 * 
 * === 확장 문제들 ===
 * 1) 가중치 있는 케빈 베이컨 수
 * 2) 동적으로 변하는 친구 관계
 * 3) k-단계 이내 도달 가능한 사람 수
 * 4) 네트워크의 지름(diameter) 계산
 * 5) 클러스터링 계수 분석
 * 
 * === 실제 응용 사례 ===
 * 1) 소셜 네트워크 분석:
 *    - LinkedIn의 연결도 분석
 *    - Facebook의 친구 추천
 *    - Twitter의 영향력 측정
 * 
 * 2) 생물학적 네트워크:
 *    - 단백질 상호작용 네트워크
 *    - 유전자 조절 네트워크
 *    - 신경망 연결성 분석
 * 
 * 3) 교통 네트워크:
 *    - 대중교통 환승 최적화
 *    - 도로망 중요도 분석
 *    - 항공편 허브 선정
 */
public class Main {
    
    static final int INF = 1000000;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // 유저의 수
        int M = sc.nextInt(); // 친구 관계의 수
        
        // 거리 배열 초기화
        int[][] dist = new int[N + 1][N + 1];
        
        // 모든 거리를 무한대로 초기화
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                if (i == j) {
                    dist[i][j] = 0; // 자기 자신과의 거리는 0
                } else {
                    dist[i][j] = INF; // 연결되지 않은 경우 무한대
                }
            }
        }
        
        // 친구 관계 입력 (무향 그래프)
        for (int i = 0; i < M; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            dist[a][b] = 1; // 직접 연결된 경우 거리 1
            dist[b][a] = 1; // 무향 그래프이므로 양방향
        }
        
        // 플로이드 워셜 알고리즘으로 모든 쌍 최단거리 계산
        for (int k = 1; k <= N; k++) {
            for (int i = 1; i <= N; i++) {
                for (int j = 1; j <= N; j++) {
                    if (dist[i][k] != INF && dist[k][j] != INF) {
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
        
        // 각 사람의 케빈 베이컨 수 계산
        int minKevinBacon = INF;
        int answer = 1;
        
        for (int i = 1; i <= N; i++) {
            int kevinBaconSum = 0;
            
            // i번 사람에서 다른 모든 사람까지의 거리 합
            for (int j = 1; j <= N; j++) {
                if (i != j) {
                    kevinBaconSum += dist[i][j];
                }
            }
            
            // 최소값 갱신 (번호가 작은 사람 우선)
            if (kevinBaconSum < minKevinBacon) {
                minKevinBacon = kevinBaconSum;
                answer = i;
            }
        }
        
        System.out.println(answer);
    }
}