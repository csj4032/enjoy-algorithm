package p9251;

import java.util.Scanner;

/**
 * 제목 : LCS (Longest Common Subsequence) - 최장 공통 부분수열
 * 링크 : https://www.acmicpc.net/problem/9251
 * 분류 : 다이나믹 프로그래밍, 문자열
 * 난이도 : Gold V
 * 
 * ========================================================================
 * ■ 문제 개요 및 핵심 개념
 * ========================================================================
 * 
 * 최장 공통 부분수열(LCS: Longest Common Subsequence) 문제는 두 수열에서 공통으로 
 * 나타나는 부분수열 중 가장 긴 것의 길이를 구하는 문제입니다.
 * 
 * ★ 부분수열(Subsequence)의 정의:
 * - 원래 수열에서 0개 이상의 원소를 제거하여 만든 수열
 * - 남은 원소들의 상대적 순서는 변하지 않아야 함
 * - 연속적일 필요는 없음 (부분문자열과 다른 점)
 * 
 * 예시: "ACAYKP"와 "CAPCAK"의 LCS는 "ACAK" (길이 4)
 * - A-C-A---K-P
 * - -C-A-P-C-A-K
 *   ↑ ↑ ↑   ↑
 *   공통 부분수열 "ACAK"
 * 
 * ========================================================================
 * ■ 수학적 원리와 이론적 배경
 * ========================================================================
 * 
 * ★ 1. 최적 부분 구조 (Optimal Substructure)
 * 
 * X = x₁x₂...xₘ, Y = y₁y₂...yₙ 두 문자열에 대해:
 * 
 * LCS(X[1..i], Y[1..j]) = 
 *   ┌ LCS(X[1..i-1], Y[1..j-1]) + 1     if xᵢ = yⱼ
 *   └ max(LCS(X[1..i-1], Y[1..j]), 
 *         LCS(X[1..i], Y[1..j-1]))      if xᵢ ≠ yⱼ
 * 
 * ★ 증명:
 * Case 1) xᵢ = yⱼ인 경우:
 * - 두 문자가 같다면 반드시 LCS에 포함될 수 있음
 * - 따라서 X[1..i-1]과 Y[1..j-1]의 LCS에 해당 문자를 추가
 * 
 * Case 2) xᵢ ≠ yⱼ인 경우:
 * - 두 문자 중 적어도 하나는 LCS에 포함되지 않음
 * - 따라서 xᵢ를 제외한 경우와 yⱼ를 제외한 경우 중 최대값 선택
 * 
 * ★ 2. 중복 부분 문제 (Overlapping Subproblems)
 * 
 * 동일한 (i, j) 조합에 대한 LCS 계산이 여러 번 발생
 * → 메모이제이션 또는 Bottom-up DP로 해결
 * 
 * ★ 3. 점화식 정의
 * 
 * dp[i][j] = X[1..i]와 Y[1..j]의 LCS 길이
 * 
 * 점화식:
 * dp[i][j] = ┌ 0                           if i=0 or j=0
 *            │ dp[i-1][j-1] + 1            if X[i] = Y[j]
 *            └ max(dp[i-1][j], dp[i][j-1]) if X[i] ≠ Y[j]
 * 
 * ========================================================================
 * ■ 알고리즘 구현 방법과 최적화
 * ========================================================================
 * 
 * ★ 1. Bottom-up DP 접근법
 * 
 * 1) 2차원 DP 테이블 dp[m+1][n+1] 생성
 * 2) 경계 조건 설정: dp[0][j] = dp[i][0] = 0
 * 3) 이중 반복문으로 테이블 채우기
 * 4) dp[m][n]이 최종 답
 * 
 * ★ 2. 공간 복잡도 최적화
 * 
 * 방법 1) Rolling Array 기법:
 * - 이전 행의 정보만 필요하므로 2개의 1차원 배열 사용
 * - 공간복잡도: O(mn) → O(min(m,n))
 * 
 * 방법 2) 1차원 배열 + 임시 변수:
 * - 한 개의 1차원 배열과 대각선 값을 저장할 변수 사용
 * - 더욱 공간 효율적
 * 
 * ★ 3. 실제 LCS 문자열 추적
 * 
 * DP 테이블을 역추적하여 실제 LCS 구성:
 * - dp[i][j]에서 시작하여 (0,0)까지 역방향 탐색
 * - X[i] = Y[j]인 경우 해당 문자를 결과에 추가
 * 
 * ========================================================================
 * ■ 시간/공간 복잡도 분석
 * ========================================================================
 * 
 * ★ 시간 복잡도: O(m × n)
 * - 2차원 DP 테이블의 각 칸을 한 번씩 계산
 * - 각 칸의 계산은 O(1) 시간
 * - m, n: 각각 첫 번째, 두 번째 문자열의 길이
 * 
 * ★ 공간 복잡도: O(m × n)
 * - 기본 구현: 2차원 DP 테이블
 * - 최적화 시: O(min(m, n))
 * 
 * ★ 개선 가능성:
 * - Hirschberg 알고리즘: O(min(m,n)) 공간으로 실제 LCS 구성
 * - Myers 알고리즘: 특정 조건에서 더 빠른 성능
 * 
 * ========================================================================
 * ■ 관련 알고리즘과의 비교
 * ========================================================================
 * 
 * ★ 1. LCS vs LIS (Longest Increasing Subsequence)
 * - LCS: 두 수열 간의 공통 부분수열
 * - LIS: 한 수열에서 증가하는 부분수열
 * - LIS는 O(n log n) 해결 가능 (이분탐색 + DP)
 * 
 * ★ 2. LCS vs Edit Distance (편집 거리)
 * - Edit Distance: 한 문자열을 다른 문자열로 변환하는 최소 비용
 * - LCS와 밀접한 관련: Edit Distance = m + n - 2×LCS
 * - 둘 다 동일한 DP 패러다임 사용
 * 
 * ★ 3. LCS vs Longest Common Substring
 * - LCS: 연속적이지 않아도 됨
 * - Longest Common Substring: 연속된 부분 문자열
 * - Substring 문제는 더 간단하게 해결 가능
 * 
 * ========================================================================
 * ■ 실전 코딩테스트 대비 포인트
 * ========================================================================
 * 
 * ★ 1. 구현 시 주의사항
 * - 인덱스 처리: 문자열은 0부터, DP는 1부터 시작
 * - 경계 조건 확실히 설정
 * - 문자 비교 시 == 대신 equals() 사용 (Java)
 * 
 * ★ 2. 메모리 제한 고려
 * - 문자열 길이가 클 때 공간 최적화 필요
 * - Rolling array 기법 숙지
 * 
 * ★ 3. 변형 문제 대응
 * - LCS 개수 세기
 * - 실제 LCS 문자열 출력
 * - 여러 문자열에 대한 LCS
 * - 가중치가 있는 LCS
 * 
 * ★ 4. 시간 제한 대응
 * - 기본 O(mn) 알고리즘으로 충분한 경우가 대부분
 * - 필요시 공간 지역성을 고려한 최적화
 * 
 * ========================================================================
 * ■ 확장 문제와 응용 사례
 * ========================================================================
 * 
 * ★ 1. 실무 응용 분야
 * - 생물정보학: DNA 서열 비교 및 유사성 분석
 * - 버전 관리: Git diff의 핵심 알고리즘
 * - 문서 비교: 문서 간 유사도 측정
 * - 스팸 필터링: 텍스트 패턴 매칭
 * - 표절 검사: 문서 간 공통 부분 탐지
 * 
 * ★ 2. 관련 심화 문제
 * - BOJ 9252: LCS 2 (실제 LCS 문자열 출력)
 * - BOJ 1958: LCS 3 (세 개 문자열의 LCS)
 * - BOJ 5582: 공통 부분 문자열 (연속된 부분)
 * - 편집 거리 관련 문제들
 * 
 * ★ 3. 고급 변형
 * - 가중치 LCS: 각 문자에 가중치 부여
 * - 제약 조건 LCS: 특정 패턴 포함/제외
 * - 근사 LCS: 일정 오차를 허용하는 LCS
 * - 병렬 LCS: 대용량 데이터 처리
 * 
 * ========================================================================
 * ■ 구현 상세 분석
 * ========================================================================
 * 
 * 현재 구현의 특징:
 * 1) String.split("")을 사용한 문자 분할 (메모리 오버헤드 존재)
 * 2) 표준적인 2차원 DP 접근법
 * 3) 명확한 점화식 구현
 * 
 * 개선 가능한 점:
 * 1) charAt() 직접 사용으로 메모리 절약
 * 2) 공간 최적화 적용 가능
 * 3) 입력 검증 추가 가능
 */
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String a = sc.nextLine();
		String b = sc.nextLine();
		System.out.println(longestCommonSubsequence(a, b));
	}

	private static int longestCommonSubsequence(String str1, String str2) {
		String[] arr1 = str1.split("");
		String[] arr2 = str2.split("");

		int n = arr1.length;
		int m = arr2.length;

		int dp[][] = new int[n + 1][m + 1];

		for (int i = 0; i < m; i++) dp[0][i] = 0;
		for (int i = 0; i < n; i++) dp[i][0] = 0;

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (arr1[i - 1].equals(arr2[j - 1])) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				} else {
					dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
				}
			}
		}
		return dp[n][m];
	}
}