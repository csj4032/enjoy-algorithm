package p12865;

import java.util.*;

/**
 * 제목 : 평범한 배낭
 * 링크 : https://www.acmicpc.net/problem/12865
 * 분류 : 다이나믹 프로그래밍, 배낭 문제
 * 
 * === 문제 해설 ===
 * 0-1 배낭 문제(0-1 Knapsack Problem)의 고전적인 최적화 문제입니다.
 * N개의 물건과 무게 한계 K인 배낭이 주어질 때, 가치의 합을 최대화하는 문제입니다.
 * 각 물건은 하나씩만 선택할 수 있습니다 (0개 또는 1개).
 * 
 * === 수학적/이론적 배경 ===
 * 1) 0-1 배낭 문제의 수학적 정의:
 *    - 목적함수: maximize Σ(vi × xi) subject to Σ(wi × xi) ≤ W
 *    - 제약조건: xi ∈ {0, 1} for all i
 *    - 이는 정수 계획법(Integer Programming)의 특수한 경우
 * 
 * 2) 최적 부분 구조(Optimal Substructure):
 *    - 물건 i를 포함하는 경우: OPT(i-1, w-wi) + vi
 *    - 물건 i를 포함하지 않는 경우: OPT(i-1, w)
 *    - OPT(i, w) = max{OPT(i-1, w), OPT(i-1, w-wi) + vi}
 * 
 * 3) 중복 부분문제(Overlapping Subproblems):
 *    - 동일한 부분문제가 여러 번 호출됨
 *    - 메모이제이션으로 중복 계산 방지
 *    - 상태 수: O(N × W)
 * 
 * 4) 벨만 최적성 원리(Bellman's Principle of Optimality):
 *    - "최적 정책의 부분 정책도 최적이다"
 *    - 동적 계획법 적용의 이론적 근거
 *    - 리처드 벨만(Richard Bellman)이 1957년 제시
 * 
 * === 알고리즘 설계 원리 ===
 * 1) 상태 정의:
 *    - dp[i][w]: 첫 i개 물건을 고려하고 무게 w일 때의 최대 가치
 *    - 0 ≤ i ≤ N, 0 ≤ w ≤ W
 *    - 총 상태 수: (N+1) × (W+1)
 * 
 * 2) 상태 전이:
 *    - 물건 i 선택 가능: wi ≤ w
 *    - 선택 안함: dp[i][w] = dp[i-1][w]
 *    - 선택함: dp[i][w] = dp[i-1][w-wi] + vi
 *    - 최종: dp[i][w] = max(위 두 경우)
 * 
 * 3) 초기 조건:
 *    - dp[0][w] = 0 for all w (물건이 없으면 가치 0)
 *    - dp[i][0] = 0 for all i (용량이 0이면 가치 0)
 * 
 * 4) 계산 순서:
 *    - Bottom-up: 작은 부문제부터 큰 부문제로
 *    - 토폴로지컬 순서로 상태 전이
 *    - 의존성 그래프의 방향성 보장
 * 
 * === 복잡도 분석 ===
 * 1) 시간복잡도:
 *    - 기본: O(N × W) - 모든 상태 계산
 *    - 각 상태당 O(1) 시간
 *    - 전체: O(N × W)
 * 
 * 2) 공간복잡도:
 *    - 2차원 DP: O(N × W)
 *    - 1차원 최적화: O(W)
 *    - 메모리 접근 패턴: 순차적
 * 
 * 3) 의사다항식시간(Pseudo-polynomial Time):
 *    - 입력 크기에 대해 다항식이 아님
 *    - 수치 값에 의존하는 시간복잡도
 *    - NP-완전 문제의 특징
 * 
 * === 고급 최적화 기법 ===
 * 1) 공간 복잡도 최적화:
 *    - 슬라이딩 윈도우: 두 개의 1차원 배열 사용
 *    - 역순 갱신: for w from W to wi
 *    - 메모리 사용량: O(W)로 감소
 * 
 * 2) 캐시 지역성 최적화:
 *    - 메모리 접근 패턴 개선
 *    - 블록 단위 계산
 *    - 프리페칭 최적화
 * 
 * 3) 분기 예측 최적화:
 *    - 조건문 순서 조정
 *    - 가장 빈번한 케이스를 앞에 배치
 *    - 컴파일러 최적화 힌트
 * 
 * 4) 대칭성 활용:
 *    - 물건 순서 변경으로 성능 향상
 *    - 가치/무게 비율로 정렬
 *    - 조기 종료 조건 강화
 * 
 * === 고급 변형 알고리즘 ===
 * 1) 분기한정법(Branch and Bound):
 *    - 상한 추정: 탐욕적 분할 가능 배낭
 *    - 가지치기: 현재 최적해보다 나쁜 경우 제거
 *    - 최악의 경우 지수시간, 평균적으로 빠름
 * 
 * 2) 코어 알고리즘(Core Algorithm):
 *    - 효율성 기준으로 정렬
 *    - 코어 주변의 작은 부분만 DP 적용
 *    - 실제로는 매우 빠른 성능
 * 
 * 3) 근사 알고리즘:
 *    - FPTAS: (1-ε) 근사해를 다항시간에
 *    - 가치 스케일링: 정확도와 시간의 트레이드오프
 *    - 실용적 성능 보장
 * 
 * 4) 병렬 알고리즘:
 *    - 상태 계산의 병렬화
 *    - GPU 가속 구현
 *    - 분산 컴퓨팅 적용
 * 
 * === 실전 구현 최적화 ===
 * 1) 메모리 레이아웃:
 *    - 연속 메모리 할당
 *    - 캐시 라인 크기 고려
 *    - False sharing 방지
 * 
 * 2) 수치 연산 최적화:
 *    - 정수 오버플로우 방지
 *    - 적절한 자료형 선택
 *    - 비트 연산 활용
 * 
 * 3) I/O 최적화:
 *    - BufferedReader 사용
 *    - StringBuilder로 출력 최적화
 *    - 메모리 매핑 파일 I/O
 * 
 * === 대안 해결법 비교 ===
 * 1) 완전 탐색:
 *    - 시간복잡도: O(2^N)
 *    - 정확한 해 보장
 *    - 작은 N에서만 실용적
 * 
 * 2) 탐욕 알고리즘:
 *    - 시간복잡도: O(N log N)
 *    - 분할 가능 배낭에서 최적
 *    - 0-1 배낭에서는 근사해
 * 
 * 3) 분기한정법:
 *    - 평균 시간복잡도: 지수시간보다 빠름
 *    - 메모리 효율적
 *    - 최적해 보장
 * 
 * 4) 메타 휴리스틱:
 *    - 유전 알고리즘, 시뮬레이티드 어닐링
 *    - 대규모 문제에 적용 가능
 *    - 근사해, 실행시간 제어 가능
 * 
 * === 실제 응용 사례 ===
 * 1) 자원 할당:
 *    - CPU 스케줄링
 *    - 메모리 할당
 *    - 네트워크 대역폭 분배
 * 
 * 2) 금융 최적화:
 *    - 포트폴리오 선택
 *    - 자본 예산 문제
 *    - 위험 관리
 * 
 * 3) 생산 계획:
 *    - 제품 mix 최적화
 *    - 용량 계획
 *    - 공급망 관리
 * 
 * 4) 데이터 마이닝:
 *    - 특성 선택
 *    - 모델 선택
 *    - 차원 축소
 * 
 * === 수학적 일반화 ===
 * 1) 다차원 배낭:
 *    - 여러 제약조건 동시 고려
 *    - 시간복잡도: 지수적 증가
 *    - 근사 알고리즘 필요
 * 
 * 2) 확률적 배낭:
 *    - 무게와 가치가 확률변수
 *    - 기댓값 최적화
 *    - 동적 계획법 확장
 * 
 * 3) 온라인 배낭:
 *    - 물건이 순차적으로 도착
 *    - 즉시 결정 필요
 *    - 경쟁 분석(Competitive Analysis)
 * 
 * === 연관 이론들 ===
 * 1) 조합 최적화:
 *    - 이산 최적화의 대표 문제
 *    - 정수 계획법과의 관계
 *    - 다면체 이론 적용
 * 
 * 2) 계산 복잡도 이론:
 *    - NP-완전 문제
 *    - 강 NP-완전성
 *    - P vs NP 문제와의 연관성
 * 
 * 3) 근사 알고리즘 이론:
 *    - 근사비 분석
 *    - PTAS, FPTAS
 *    - 근사 불가능성 결과
 * 
 * === 확장 문제들 ===
 * 1) 다중 배낭 (Multiple Knapsack)
 * 2) 무제한 배낭 (Unbounded Knapsack)  
 * 3) 분할 가능 배낭 (Fractional Knapsack)
 * 4) 배낭 + 배송 문제 (Knapsack with Delivery)
 * 5) 시간 제한 배낭 (Time-constrained Knapsack)
 */
public class Main {

	static int m[];
	static int w[];
	static int v[];
	static long dp[][];

	public static void main(String[] args) {
		var sc = new Scanner(System.in);
		var n = sc.nextInt();
		var k = sc.nextInt();
		m = new int[n];
		w = new int[n];
		v = new int[n];
		dp = new long[n + 1][k + 1];

		for (int i = 0; i < n; i++) {
			w[i] = sc.nextInt();
			v[i] = sc.nextInt();
		}

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= k; j++) {
				if (w[i - 1] <= j) {
					dp[i][j] = Math.max(v[i - 1] + dp[i - 1][j - w[i - 1]], dp[i - 1][j]);
				} else {
					dp[i][j] = dp[i - 1][j];
				}
			}
		}
		System.out.println(dp[n][k]);
		System.out.println(Arrays.deepToString(dp));
	}

	private static void display(long[][] dp) {
		for (int i = 0; i < dp.length; i++) {
			for (int j = 0; j < dp[0].length; j++) {
				System.out.print(dp[i][j] + " ");
			}
			System.out.println();
		}
	}
}
/*
5 7
6 13
4 8
2 10
3 6
5 12

4 7
1 1000
2 1000
3 1000
5 1000

4 7
3 6
4 8
5 12
6 13

4 7
3 6
5 18
4 8
5 12

8 4
1 3
1 6
1 3
1 3
1 3
1 2
1 5
1 8

 */