package p1463;

import java.util.Scanner;

/*
 * 백준 1463번: 1로 만들기
 * https://www.acmicpc.net/problem/1463
 * 
 * [문제 분류] 동적 계획법(DP) / 그래프 탐색
 * [난이도] Silver 3
 * 
 * [문제 요약]
 * 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지이다.
 * 1. X가 3으로 나누어떨어지면, 3으로 나눈다.
 * 2. X가 2로 나누어떨어지면, 2로 나눈다.
 * 3. 1을 뺀다.
 * 정수 N이 주어졌을 때, 위와 같은 연산을 써서 1을 만들려고 한다. 
 * 연산을 사용하는 횟수의 최솟값을 출력하시오.
 * 
 * [제약 조건]
 * - 1 ≤ N ≤ 1,000,000
 * 
 * [알고리즘 설명 - Bottom-up DP]
 * 1. 핵심 아이디어: dp[i] = i를 1로 만드는 최소 연산 횟수
 * 2. 점화식: dp[i] = min(가능한 모든 이전 상태) + 1
 * 3. 가능한 이전 상태:
 *    - i가 3으로 나누어떨어지면: dp[i/3] + 1
 *    - i가 2로 나누어떨어지면: dp[i/2] + 1  
 *    - 항상 가능: dp[i-1] + 1
 * 
 * [DP 전략 선택]
 * 1. Top-down (메모이제이션):
 *    - 재귀 + 메모 배열
 *    - 필요한 부분만 계산
 *    - 스택 오버플로우 위험
 * 
 * 2. Bottom-up (테뷸레이션):
 *    - 반복문 + DP 배열
 *    - 1부터 N까지 순차 계산
 *    - 메모리 효율적, 안정적
 * 
 * [현재 코드 분석]
 * 현재 구현: 백트래킹을 이용한 완전탐색
 * 문제점:
 * - 시간복잡도: O(3^N) - 지수적 증가
 * - 중복 계산 발생
 * - N이 클 때 매우 비효율적
 * 
 * [효율적인 DP 구현]
 * int[] dp = new int[N + 1];
 * dp[1] = 0; // Base case
 * 
 * for (int i = 2; i <= N; i++) {
 *     dp[i] = dp[i - 1] + 1; // 1을 빼는 연산
 *     
 *     if (i % 2 == 0) {
 *         dp[i] = Math.min(dp[i], dp[i / 2] + 1);
 *     }
 *     
 *     if (i % 3 == 0) {
 *         dp[i] = Math.min(dp[i], dp[i / 3] + 1);
 *     }
 * }
 * 
 * [최적화 고려사항]
 * 1. 연산 순서 최적화:
 *    - 나누기 연산을 먼저 시도하는 것이 일반적으로 유리
 *    - 하지만 DP에서는 모든 경우를 고려하므로 순서 무관
 * 
 * 2. 메모리 최적화:
 *    - 현재: O(N) 공간 필요
 *    - BFS 방식으로 구현하면 일정 공간으로 해결 가능
 * 
 * 3. 조기 종료:
 *    - 백트래킹에서 가지치기 적용 (현재 코드에 구현됨)
 * 
 * [BFS 대안 해법]
 * BFS로도 해결 가능 (레벨별 탐색):
 * - 각 레벨이 연산 횟수
 * - 처음 1에 도달하는 레벨이 답
 * - 메모리 사용량이 적음
 * 
 * [그리디는 불가능]
 * - 10의 경우: 10 → 9 → 3 → 1 (3번) vs 10 → 5 → 4 → 2 → 1 (4번)
 * - 매 단계에서 최적 선택이 전체 최적해를 보장하지 않음
 * 
 * [코딩테스트 관점]
 * - DP 기본 문제의 대표 사례
 * - Bottom-up vs Top-down 비교 학습
 * - 백트래킹과 DP의 차이점 이해
 * - 시간복잡도 분석 능력
 * 
 * [관련 문제들]
 * - 2×n 타일링 (11726번) - 기본 DP
 * - 계단 오르기 (2579번) - 조건부 DP
 * - 피보나치 함수 (1003번) - DP + 수학
 * - RGB거리 (1149번) - 다차원 DP
 * 
 * [실제 응용]
 * - 게임에서 최소 이동 횟수 계산
 * - 수학 연산 최적화
 * - 상태 전이 최소 비용 문제
 * 
 * [시간복잡도] 
 * - 현재 백트래킹: O(3^N) - 매우 비효율적
 * - DP 개선: O(N) - 선형 시간
 * 
 * [공간복잡도]
 * - 백트래킹: O(N) - 재귀 스택
 * - DP: O(N) - DP 배열
 */
public class Main {

    static int k = 1000000000;  // 최소 연산 횟수를 저장할 변수

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        recursive(n, 0);  // 백트래킹으로 모든 경우의 수 탐색
        System.out.println(k);
    }

    /**
     * 백트래킹을 이용한 완전탐색 함수
     * @param n 현재 숫자
     * @param m 현재까지의 연산 횟수
     */
    private static void recursive(int n, int m) {
        if (n == 1 && k > m) k = m;  // 1에 도달하면 최소값 갱신
        if (k <= m) return;  // 가지치기: 현재 연산 횟수가 최소값보다 크면 중단
        
        // 3가지 연산을 모두 시도해보기
        if (n % 3 == 0) recursive(n / 3, m + 1);  // 3으로 나누기
        if (n % 2 == 0) recursive(n / 2, m + 1);  // 2로 나누기
        recursive(n - 1, m + 1);  // 1 빼기
    }
}