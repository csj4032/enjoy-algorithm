package p2448;

import java.util.Scanner;
import java.util.stream.Stream;

import static java.lang.System.in;

/**
 * 제목 : 별 찍기 11 - Sierpiński Triangle using Divide and Conquer
 * 링크 : https://www.acmicpc.net/problem/2448
 * 분류 : 분할정복, 재귀, 프랙탈 기하학
 * 난이도 : Gold V
 * 
 * ========================================================================
 * ■ 문제 개요 및 핵심 개념
 * ========================================================================
 * 
 * 시에르핀스키 삼각형(Sierpiński Triangle)을 출력하는 문제입니다.
 * 이는 수학적으로 유명한 프랙탈 구조로, 자기 유사성(Self-similarity)을 
 * 가지는 기하학적 패턴입니다.
 * 
 * ★ 문제 조건:
 * - N = 3 × 2^k (k ≥ 0) 형태의 높이
 * - 별(*)과 공백으로 구성된 삼각형 패턴
 * - 재귀적 구조: 큰 삼각형이 작은 삼각형 3개로 구성
 * 
 * ★ 기본 패턴 (N=3):
 *   *
 *  * *
 * *****
 * 
 * ★ 확장 패턴 (N=6):
 *      *
 *     * *
 *    *****
 *   *     *
 *  * *   * *
 * ***** *****
 * 
 * ========================================================================
 * ■ 수학적 원리와 이론적 배경
 * ========================================================================
 * 
 * ★ 1. 시에르핀스키 삼각형의 수학적 정의
 * 
 * 시에르핀스키 삼각형은 폴란드 수학자 바츨라프 시에르핀스키(Wacław Sierpiński)가
 * 1915년에 연구한 프랙탈 구조입니다.
 * 
 * 수학적 정의:
 * 1) 정삼각형에서 시작
 * 2) 각 변의 중점을 연결하여 4개의 작은 삼각형으로 분할
 * 3) 가운데 삼각형을 제거
 * 4) 남은 3개 삼각형에 대해 재귀적으로 반복
 * 
 * ★ 2. 프랙탈 차원 (Fractal Dimension)
 * 
 * 하우스도르프 차원(Hausdorff dimension):
 * d = log(3) / log(2) ≈ 1.585
 * 
 * 이는 시에르핀스키 삼각형이 1차원(선)보다는 복잡하지만
 * 2차원(면)보다는 단순한 구조임을 의미합니다.
 * 
 * ★ 3. 자기 유사성 (Self-similarity)
 * 
 * 시에르핀스키 삼각형의 핵심 특성:
 * - 전체 구조가 부분 구조와 동일한 형태
 * - 스케일링 팩터: 1/2
 * - 복사본 개수: 3개
 * 
 * 수학적 표현:
 * S = f₁(S) ∪ f₂(S) ∪ f₃(S)
 * 
 * 여기서 fᵢ는 각각 1/2 축소 + 적절한 위치 이동을 나타내는 아핀 변환
 * 
 * ★ 4. 이진법과의 관련성
 * 
 * 파스칼 삼각형에서 홀수인 항목만 표시하면 시에르핀스키 삼각형이 나타납니다.
 * 이는 루카스 정리(Lucas' theorem)와 밀접한 관련이 있습니다.
 * 
 * C(n,k) ≡ ∏ᵢ C(nᵢ,kᵢ) (mod 2)
 * 
 * 여기서 n = Σnᵢ×2ⁱ, k = Σkᵢ×2ⁱ는 이진 표현입니다.
 * 
 * ========================================================================
 * ■ 분할정복 알고리즘 설계와 구현
 * ========================================================================
 * 
 * ★ 1. 분할정복 패러다임 적용
 * 
 * 문제 분할:
 * - 크기 N인 삼각형 → 크기 N/2인 삼각형 3개
 * - 상단 1개 + 하단 2개로 배치
 * 
 * 정복 (Conquer):
 * - 기저 사례: N=3일 때 직접 출력
 * - 재귀 사례: 부분 문제 해결 후 결합
 * 
 * 결합 (Combine):
 * - 상단 삼각형: 양쪽에 공백 추가
 * - 하단 삼각형들: 인접하게 배치
 * 
 * ★ 2. 메모리 효율적인 구현 전략
 * 
 * 현재 구현의 특징:
 * 1) 문자열 배열을 사용한 라인별 저장
 * 2) 반복적 확장(Bottom-up) 방식
 * 3) 공간 복잡도: O(N) (출력 크기와 동일)
 * 
 * 대안적 구현:
 * 1) 재귀적 생성 (Top-down)
 * 2) 2차원 문자 배열 사용
 * 3) 실시간 계산 (메모리 사용량 최소화)
 * 
 * ★ 3. 패턴 생성 알고리즘 분석
 * 
 * 현재 구현의 핵심 로직:
 * ```java
 * // 수직 결합 (상단 삼각형)
 * arr[j] = "   " + arr[j] + "   ";
 * 
 * // 수평 결합 (하단 삼각형들)  
 * arr[copyHeight + j] = arr[j] + " " + arr[j];
 * ```
 * 
 * 이는 다음과 같은 변환을 의미:
 * - 상단: 3×2^(k-1) 만큼 좌우 패딩 추가
 * - 하단: 가운데 공백 1개로 두 삼각형 연결
 * 
 * ★ 4. 공간과 시간 복잡도 최적화
 * 
 * 시간 복잡도: O(N²)
 * - 총 출력 문자 수가 O(N²)이므로 최적
 * - 각 레벨에서 O(N) 작업, 총 O(log N) 레벨
 * 
 * 공간 복잡도: O(N²)
 * - 문자열 저장에 필요한 공간
 * - 최종 출력 크기와 동일하므로 최적
 * 
 * ========================================================================
 * ■ 프랙탈 기하학과 응용 분야
 * ========================================================================
 * 
 * ★ 1. 프랙탈의 일반적 특성
 * 
 * 프랙탈의 정의 (벤와 만델브로, 1982):
 * 1) 자기 유사성: 부분이 전체와 유사한 구조
 * 2) 복잡성: 모든 스케일에서 세부 구조 존재
 * 3) 비정수 차원: 하우스도르프 차원이 비정수
 * 4) 무한 반복: 이론적으로 무한히 세분화 가능
 * 
 * ★ 2. 자연계에서의 프랙탈
 * 
 * 자연 현상의 프랙탈 특성:
 * - 해안선의 길이 (리처드슨 효과)
 * - 구름의 모양
 * - 나무의 분지 구조
 * - 혈관계 네트워크
 * - 번개의 경로
 * 
 * ★ 3. 컴퓨터 그래픽스 응용
 * 
 * 절차적 생성 (Procedural Generation):
 * - 지형 생성: 다이아몬드-스퀘어 알고리즘
 * - 텍스처 합성: 퍼린 노이즈 변형
 * - 식물 모델링: L-시스템 기반 생성
 * - 클라우드 렌더링: 볼류메트릭 렌더링
 * 
 * ★ 4. 데이터 압축과 분석
 * 
 * 프랙탈 압축:
 * - 이미지의 자기 유사성 활용
 * - 반복 함수 시스템 (IFS) 인코딩
 * - 고압축률 달성 가능
 * 
 * 프랙탈 분석:
 * - 의료 영상 분석 (종양 경계 복잡도)
 * - 주식 시장 패턴 분석
 * - 네트워크 트래픽 특성 분석
 * 
 * ========================================================================
 * ■ 관련 알고리즘과 패턴 비교
 * ========================================================================
 * 
 * ★ 1. 다른 프랙탈 구조와의 비교
 * 
 * 칸토르 집합 (1차원):
 * - 선분을 3등분하여 가운데 제거
 * - 차원: log(2)/log(3) ≈ 0.631
 * - 구현: 1차원 배열로 처리 가능
 * 
 * 코흐 곡선 (1차원 곡선):
 * - 각 변을 4개 구간으로 나누고 중간에 삼각 돌기 추가
 * - 차원: log(4)/log(3) ≈ 1.262
 * - 구현: 좌표 계산 필요
 * 
 * 망델브로 집합 (2차원):
 * - 복소평면에서 반복 함수의 발산 특성
 * - 차원: 약 2 (경계에서 프랙탈 특성)
 * - 구현: 복소수 연산 필요
 * 
 * ★ 2. 패턴 생성 알고리즘 비교
 * 
 * 셀룰러 오토마타:
 * - 규칙 90: 시에르핀스키 삼각형과 유사한 패턴
 * - 1차원 규칙으로 2차원 패턴 생성
 * - 시간 복잡도: O(N²), 공간: O(N)
 * 
 * L-시스템 (Lindenmayer System):
 * - 문법 기반 패턴 생성
 * - 문자열 재작성 규칙
 * - 더 복잡한 구조 표현 가능
 * 
 * 터틀 그래픽스:
 * - 명령어 기반 그래픽 생성
 * - 상태 저장/복원을 통한 분기 구조
 * - 교육용으로 직관적
 * 
 * ★ 3. 재귀 vs 반복 구현 비교
 * 
 * 재귀적 구현:
 * ```java
 * void sierpinski(int n, int row, int col) {
 *     if (n == 3) drawBaseTriangle(row, col);
 *     else {
 *         sierpinski(n/2, row, col + n/2);
 *         sierpinski(n/2, row + n/2, col);
 *         sierpinski(n/2, row + n/2, col + n);
 *     }
 * }
 * ```
 * 
 * 반복적 구현 (현재):
 * - 메모리 사용량이 더 예측 가능
 * - 스택 오버플로우 위험 없음
 * - 디버깅이 더 용이
 * 
 * ========================================================================
 * ■ 실전 코딩테스트 대비 포인트
 * ========================================================================
 * 
 * ★ 1. 분할정복 문제 특징 파악
 * 
 * 분할정복이 적합한 조건:
 * - 문제가 동일한 구조의 하위 문제로 분할 가능
 * - 하위 문제들이 독립적으로 해결 가능
 * - 하위 문제 해답을 결합하여 원래 문제 해결 가능
 * 
 * 이 문제의 특징:
 * - 자기 유사성이 명확함
 * - 각 하위 삼각형이 독립적
 * - 공간적 배치 규칙이 일정함
 * 
 * ★ 2. 구현 시 주의사항
 * 
 * 1) 문자열 조작 최적화:
 *    - StringBuilder 사용 고려
 *    - 불필요한 문자열 복사 방지
 *    - 메모리 사용량 모니터링
 * 
 * 2) 패턴 규칙 정확성:
 *    - 공백과 별의 개수 정확히 계산
 *    - 대칭성 유지
 *    - 경계 조건 체크
 * 
 * 3) 출력 형식 준수:
 *    - 각 줄 끝의 공백 처리
 *    - 전체 너비 일관성
 *    - 개행 문자 정확한 사용
 * 
 * ★ 3. 메모리 및 성능 최적화
 * 
 * 공간 최적화:
 * - 필요한 경우만 문자열 저장
 * - 실시간 계산으로 메모리 절약
 * - 문자 배열 대신 문자열 사용의 장단점 고려
 * 
 * 시간 최적화:
 * - 반복되는 문자열 계산 캐싱
 * - 불필요한 문자 연결 연산 최소화
 * - StringBuilder의 적절한 용량 설정
 * 
 * ★ 4. 디버깅 전략
 * 
 * 작은 케이스부터 검증:
 * - N=3: 기본 삼각형 정확성
 * - N=6: 첫 번째 확장 규칙
 * - N=12: 두 번째 확장 규칙
 * 
 * 시각적 검증:
 * - 대칭성 확인
 * - 빈 공간 패턴 점검
 * - 전체적인 균형감 검토
 * 
 * ========================================================================
 * ■ 확장 문제와 심화 학습
 * ========================================================================
 * 
 * ★ 1. 관련 심화 문제
 * 
 * BOJ 문제들:
 * - 2447: 별 찍기 10 (칸토르 집합 변형)
 * - 11729: 하노이 탑 이동 순서 (분할정복)
 * - 1992: 쿼드트리 (2차원 분할정복)
 * - 2630: 색종이 만들기 (분할정복)
 * 
 * 고급 프랙탈 문제:
 * - 드래곤 커브 (Heighway dragon)
 * - 힐베르트 곡선 (Space-filling curve)
 * - 줄리아 집합 (Julia set)
 * 
 * ★ 2. 실무 응용 프로젝트
 * 
 * 컴퓨터 그래픽스:
 * - OpenGL/WebGL을 이용한 3D 프랙탈 렌더링
 * - 쉐이더를 활용한 실시간 프랙탈 생성
 * - VR/AR 환경에서의 몰입형 프랙탈 경험
 * 
 * 데이터 시각화:
 * - 계층적 데이터의 트리맵 표현
 * - 네트워크 구조의 프랙탈 레이아웃
 * - 시계열 데이터의 다중 스케일 분석
 * 
 * 알고리즘 교육:
 * - 재귀와 분할정복 개념 시각화
 * - 수학적 패턴의 프로그램적 표현
 * - 계산 복잡도 개념 학습 도구
 * 
 * ★ 3. 수학적 확장 연구
 * 
 * 일반화된 시에르핀스키 삼각형:
 * - n진법 기반 확장 (3진법, 4진법 등)
 * - 다른 기하학적 도형에의 적용
 * - 확률적 프랙탈 변형
 * 
 * 다차원 확장:
 * - 3차원 시에르핀스키 피라미드
 * - 4차원 이상의 하이퍼 프랙탈
 * - 위상학적 특성 분석
 * 
 * 동적 프랙탈:
 * - 시간에 따라 변화하는 프랙탈
 * - 매개변수화된 프랙탈 함수
 * - 적응적 상세도 조절
 * 
 * ========================================================================
 * ■ 현재 구현의 분석 및 개선 방향
 * ========================================================================
 * 
 * 현재 구현의 장점:
 * 1) 간결하고 효율적인 반복적 접근
 * 2) 메모리 사용량이 예측 가능
 * 3) 스택 오버플로우 위험 없음
 * 4) Java 8 스트림을 활용한 간결한 출력
 * 
 * 개선 가능한 부분:
 * 1) 더 명확한 변수명과 주석
 * 2) 매직 넘버 제거 (3, 5 등)
 * 3) 입력 검증 및 예외 처리
 * 4) 다양한 크기에 대한 성능 분석
 * 
 * 교육적 가치:
 * 1) 프랙탈 기하학 개념 학습
 * 2) 분할정복 패러다임 이해
 * 3) 문자열 처리 기법 연습
 * 4) 수학과 프로그래밍의 융합 사례
 */

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(in);
		String[] arr;
		int copyHeight = 3;
		int n = sc.nextInt();
		int m = (int) (Math.log(n / 3) / Math.log(2)) + 1;
		arr = new String[n];

		arr[0] = "  *  ";
		arr[1] = " * * ";
		arr[2] = "*****";

		for (int i = 1; i < m; i++) {
			for (int j = 0; j < copyHeight; j++) {
				arr[copyHeight + j] = arr[j] + " " + arr[j];
				for (int k = 0; k < copyHeight / 3; k++) {
					arr[j] = "   " + arr[j] + "   ";
				}
			}
			copyHeight *= 2;
		}

		Stream.of(arr).forEach(System.out::println);
	}
}