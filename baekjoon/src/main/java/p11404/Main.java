package p11404;

import java.util.Scanner;

/**
 * 제목 : 플로이드
 * 링크 : https://www.acmicpc.net/problem/11404
 * 분류 : 최단경로, 플로이드 워셜, 그래프
 * 
 * === 문제 해설 ===
 * 모든 정점 쌍 사이의 최단 거리를 구하는 문제입니다.
 * 플로이드 워셜 알고리즘의 대표적인 적용 사례입니다.
 * 
 * === 수학적/이론적 배경 ===
 * 1) 플로이드 워셜 알고리즘의 원리:
 *    - 동적 계획법(Dynamic Programming)을 기반으로 함
 *    - 중간 정점을 경유하는 경로를 점진적으로 고려
 *    - k번째 단계: 1~k번 정점을 경유지로 사용할 수 있는 최단경로
 * 
 * 2) 최적 부분구조(Optimal Substructure):
 *    - dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
 *    - 부분 경로도 최단경로여야 전체 경로가 최단경로
 *    - 삼각 부등식(Triangle Inequality)의 반복 적용
 * 
 * 3) 중복 부분문제(Overlapping Subproblems):
 *    - 동일한 부분경로가 여러 경로에서 재사용됨
 *    - 메모이제이션을 통한 중복 계산 방지
 *    - 3차원 → 2차원 공간 최적화 가능
 * 
 * === 알고리즘 설계 ===
 * 1) 3중 반복문 구조:
 *    - 외부 루프(k): 경유 정점
 *    - 내부 루프(i,j): 출발-도착 정점 쌍
 *    - 순서가 중요: k가 가장 바깥쪽이어야 함
 * 
 * 2) 초기화 전략:
 *    - 자기 자신: distance[i][i] = 0
 *    - 직접 연결: 간선 가중치
 *    - 연결되지 않음: 무한대(INF)
 * 
 * 3) 갱신 조건:
 *    - dist[i][k] + dist[k][j] < dist[i][j]
 *    - 오버플로우 방지를 위한 INF 값 설정
 *    - 중간 계산의 안전성 보장
 * 
 * === 구현 세부사항 ===
 * 1) 무한대 값 설정:
 *    - INF = 1,000,000,000 (10^9)
 *    - 간선 가중치 최대값 고려
 *    - 덧셈 연산시 오버플로우 방지
 * 
 * 2) 중복 간선 처리:
 *    - Math.min()으로 최소값 선택
 *    - 동일한 방향의 여러 간선 중 최소 비용 선택
 *    - 입력 단계에서 미리 처리
 * 
 * 3) 출력 형식:
 *    - 도달 불가능한 경우 0 출력
 *    - StringBuilder로 효율적 문자열 구성
 *    - 공백과 줄바꿈 처리
 * 
 * === 시간/공간 복잡도 ===
 * - 시간복잡도: O(V³) - 3중 반복문
 * - 공간복잡도: O(V²) - 2차원 거리 배열
 * - V: 정점 수, E: 간선 수
 * - 조밀한 그래프에서 효율적 (E ≈ V²)
 * 
 * === 고급 최적화 기법 ===
 * 1) 공간 최적화:
 *    - In-place 갱신: 별도 배열 불필요
 *    - 3차원 → 2차원으로 차원 축소
 *    - 메모리 사용량 1/V로 절약
 * 
 * 2) 조기 종료 최적화:
 *    - 음수 사이클 검출시 중단
 *    - 갱신이 없는 경우 조기 종료
 *    - 특정 정점 쌍만 필요한 경우 부분 계산
 * 
 * 3) 비트 연산 최적화:
 *    - 경로 존재 여부만 필요한 경우
 *    - 비트마스크를 이용한 공간 절약
 *    - 워샬 알고리즘으로 변형
 * 
 * === 실전 코딩테스트 대비 포인트 ===
 * 1) 알고리즘 선택 기준:
 *    - 모든 쌍 최단경로: 플로이드 워셜
 *    - 단일 출발점: 다익스트라
 *    - 음수 가중치: 벨만-포드
 * 
 * 2) 구현 주의사항:
 *    - k 루프가 가장 바깥쪽
 *    - INF 값 적절히 설정
 *    - 중복 간선 처리
 *    - 오버플로우 방지
 * 
 * 3) 디버깅 포인트:
 *    - 초기화 확인
 *    - 루프 순서 확인
 *    - 인덱스 범위 확인
 *    - 출력 형식 확인
 * 
 * === 플로이드 워셜의 확장 ===
 * 1) 경로 복원:
 *    - next[i][j]: i에서 j로 가는 경로의 다음 정점
 *    - 재귀적으로 전체 경로 복원 가능
 * 
 * 2) 음수 사이클 검출:
 *    - dist[i][i] < 0인 경우 음수 사이클 존재
 *    - 모든 i에 대해 검사 필요
 * 
 * 3) 이행 폐쇄(Transitive Closure):
 *    - 경로의 존재 여부만 계산
 *    - 워샬 알고리즘(Warshall's Algorithm)
 * 
 * === 관련 알고리즘 패러다임 ===
 * 1) 동적 계획법:
 *    - 최적 부분구조 활용
 *    - 중복 부분문제 해결
 *    - 상향식 접근법
 * 
 * 2) 그래프 알고리즘:
 *    - 다익스트라 (단일 출발점)
 *    - 벨만-포드 (음수 가중치)
 *    - Johnson's 알고리즘 (희소 그래프)
 * 
 * 3) 행렬 연산:
 *    - 인접 행렬의 거듭제곱
 *    - 행렬 곱셈의 최적화
 *    - 분할 정복을 통한 성능 향상
 * 
 * === 실제 응용 사례 ===
 * 1) 네트워크 라우팅:
 *    - 인터넷 라우팅 테이블 구성
 *    - 네트워크 지연시간 최소화
 *    - 대역폭 최적화
 * 
 * 2) 교통 시스템:
 *    - 도시 간 최단 거리 계산
 *    - 대중교통 노선 최적화
 *    - 물류 배송 경로 계획
 * 
 * 3) 게임 AI:
 *    - 게임 맵에서 경로 계획
 *    - NPC 이동 최적화
 *    - 전략 게임의 영향력 계산
 * 
 * === 변형 문제들 ===
 * 1) 제한된 간선 수로 최단경로
 * 2) k번째 최단경로 찾기
 * 3) 경로 개수 세기
 * 4) 최대 용량 경로 찾기
 * 5) 시간에 따라 변하는 그래프
 */
public class Main {

	public static final int INF = 1000_000_000;

	public static void main(String[] args) {
		var sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();

		int[][] distance = new int[n+1][n+1];

		// 거리 배열 초기화
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if(i == j) continue; // 자기 자신으로의 거리는 0
				distance[i][j] = INF; // 나머지는 무한대로 초기화
			}
		}

		// 간선 정보 입력 및 중복 간선 처리
		for (int i = 0; i < m; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			int d = sc.nextInt();
			// 같은 방향의 여러 간선 중 최소 비용 선택
			distance[x][y] = Math.min(distance[x][y], d);
		}

		// 플로이드 워셜 알고리즘 수행
		// k: 경유 정점 (가장 바깥쪽 루프)
		for (int k = 1; k <= n; k++) {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					// i→k→j 경로가 i→j 직접 경로보다 짧으면 갱신
					if (distance[i][k] != INF && distance[k][j] != INF) {
						distance[i][j] = Math.min(distance[i][k] + distance[k][j], distance[i][j]);
					}
				}
			}
		}

		// 결과 출력
		StringBuilder sb = new StringBuilder();
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (distance[i][j] >= INF) {
					sb.append("0 "); // 도달 불가능
				} else {
					sb.append(distance[i][j] + " ");
				}
			}
			sb.append("\n");
		}

		System.out.println(sb.toString());
	}
}