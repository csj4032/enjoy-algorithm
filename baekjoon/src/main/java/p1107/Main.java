package p1107;

import java.util.*;

/**
 * 제목 : 리모컨 - Brute Force Search with Optimization
 * 링크 : https://www.acmicpc.net/problem/1107
 * 분류 : 브루트포스, 완전탐색, 수학
 * 난이도 : Gold V
 * 
 * ========================================================================
 * ■ 문제 개요 및 핵심 개념
 * ========================================================================
 * 
 * TV 리모컨으로 원하는 채널로 이동하는 최소 버튼 누름 횟수를 구하는 문제입니다.
 * 현재 채널은 100번이고, 숫자 버튼(0~9)과 +/- 버튼을 사용할 수 있으며,
 * 일부 숫자 버튼이 고장나 있을 수 있습니다.
 * 
 * ★ 문제 조건:
 * - 현재 채널: 100번
 * - 목표 채널: N (0 ≤ N ≤ 500,000)
 * - 사용 가능한 버튼: +, -, 0~9 중 고장나지 않은 것들
 * - +/- 버튼: 채널을 1씩 증가/감소 (0 이하로는 갈 수 없음)
 * - 숫자 버튼: 채널 번호를 직접 입력
 * 
 * ★ 해결 전략:
 * 1) +/- 버튼만 사용: |N - 100|번 누르기
 * 2) 숫자 버튼 + +/- 버튼 조합: 가능한 모든 채널 번호를 브루트포스로 확인
 * 
 * ========================================================================
 * ■ 수학적 원리와 이론적 배경
 * ========================================================================
 * 
 * ★ 1. 브루트포스 탐색의 이론적 근거
 * 
 * 이 문제는 최적화 문제로, 다음과 같이 수식화할 수 있습니다:
 * 
 * minimize: f(c) = digits(c) + |N - c|
 * subject to: c는 고장나지 않은 버튼으로만 구성 가능한 채널 번호
 * 
 * 여기서:
 * - digits(c): 채널 c의 자릿수 (숫자 버튼을 누르는 횟수)
 * - |N - c|: c에서 N으로 가기 위한 +/- 버튼 누름 횟수
 * 
 * ★ 2. 탐색 공간의 수학적 분석
 * 
 * 탐색해야 할 채널 번호의 범위:
 * - 하한: 0 (채널 번호는 0 이상)
 * - 상한: 이론적으로는 무한대, 실제로는 적절한 값으로 제한
 * 
 * 상한 설정의 근거:
 * - N = 500,000일 때, +/- 버튼만 사용하면 400,000번 필요
 * - 7자리 수 (1,000,000)를 입력하고 500,000번 -를 누르면 총 1,500,006번
 * - 따라서 500,000보다 큰 수를 고려할 필요가 없음
 * - 실제로는 999,999 정도까지만 확인하면 충분
 * 
 * ★ 3. 그리디 알고리즘과의 비교
 * 
 * 이 문제를 그리디 방식으로 접근하면:
 * - 목표 채널에 가장 가까운 만들 수 있는 채널을 선택
 * - 하지만 이는 항상 최적해를 보장하지 않음
 * 
 * 반례: N = 55, 고장난 버튼 = {6}
 * - 그리디: 50 → 5번 + → 총 7번
 * - 최적: 100 → 45번 - → 총 45번... 아니다!
 * - 실제 최적: 555 → 500번 - → 총 503번... 이것도 아니다!
 * - 실제 최적: +/- 버튼만 사용 → 45번
 * 
 * 따라서 모든 경우를 다 확인하는 브루트포스가 필요합니다.
 * 
 * ★ 4. 복잡도 분석
 * 
 * 시간 복잡도:
 * - 채널 번호 범위: O(10^6)
 * - 각 채널 번호의 유효성 검사: O(log N) (자릿수)
 * - 전체: O(10^6 × log N) = O(10^7) 정도
 * 
 * 공간 복잡도: O(1) (고장난 버튼 정보만 저장)
 * 
 * ========================================================================
 * ■ 구현 방법과 최적화 기법
 * ========================================================================
 * 
 * ★ 1. 기본 브루트포스 알고리즘
 * 
 * 1) +/- 버튼만 사용하는 경우의 비용 계산
 * 2) 0부터 적절한 상한까지 모든 채널 번호에 대해:
 *    a) 해당 채널 번호를 만들 수 있는지 확인
 *    b) 만들 수 있다면 총 비용 계산 후 최솟값 갱신
 * 
 * ★ 2. 채널 번호 유효성 검사 최적화
 * 
 * 방법 1) 문자열 변환:
 * ```java
 * String channel = String.valueOf(num);
 * for (char c : channel.toCharArray()) {
 *     if (broken[c - '0']) return false;
 * }
 * ```
 * 
 * 방법 2) 수학적 접근:
 * ```java
 * int temp = num;
 * if (temp == 0) return !broken[0];
 * while (temp > 0) {
 *     if (broken[temp % 10]) return false;
 *     temp /= 10;
 * }
 * ```
 * 
 * ★ 3. 탐색 범위 최적화
 * 
 * 불필요한 계산 줄이기:
 * - 상한선을 N + 500,000 정도로 설정
 * - N이 작을 때는 더 작은 범위로 제한 가능
 * - 7자리 이상의 수는 거의 항상 비효율적
 * 
 * ★ 4. 조기 종료 최적화
 * 
 * 현재 최솟값보다 자릿수만으로도 큰 경우 스킫:
 * ```java
 * if (digits >= minCost) continue;
 * ```
 * 
 * ========================================================================
 * ■ 경계 조건과 특수 케이스 처리
 * ========================================================================
 * 
 * ★ 1. 특수 입력 케이스
 * 
 * 1) N = 100인 경우:
 *    - 이미 목표 채널이므로 답은 0
 * 
 * 2) 모든 숫자 버튼이 고장난 경우:
 *    - +/- 버튼만 사용 가능
 *    - 답은 |N - 100|
 * 
 * 3) 특정 숫자만 사용 가능한 경우:
 *    - 예: 1만 사용 가능 → 111, 1111 등만 생성 가능
 * 
 * 4) N = 0인 경우:
 *    - 0 버튼이 고장나지 않았다면 1번 + 100번 - = 101번
 *    - 0 버튼이 고장났다면 100번 - = 100번
 * 
 * ★ 2. 오버플로우 방지
 * 
 * Java int 범위 내에서 처리:
 * - 채널 번호 최대값: 999,999 (6자리)
 * - 계산 과정에서 오버플로우 위험 없음
 * 
 * ★ 3. 성능 고려사항
 * 
 * 큰 N값과 많은 고장난 버튼:
 * - N = 500,000, 고장난 버튼 9개인 경우
 * - 브루트포스가 여전히 충분히 빠름
 * - 현대 컴퓨터에서 10^7 연산은 0.1초 내외
 * 
 * ========================================================================
 * ■ 관련 알고리즘과의 비교
 * ========================================================================
 * 
 * ★ 1. 다른 탐색 알고리즘과의 비교
 * 
 * DFS/BFS 접근:
 * - 상태: (현재 채널, 누른 횟수)
 * - 전이: +1, -1, 또는 새로운 채널 번호 입력
 * - 문제점: 상태 공간이 너무 큼, 메모리 부족
 * 
 * 다이나믹 프로그래밍:
 * - dp[i] = 채널 i에 도달하는 최소 비용
 * - 문제점: 채널 번호 범위가 너무 큼, 불필요한 계산 많음
 * 
 * 브루트포스의 장점:
 * - 구현 간단
 * - 공간 복잡도 낮음
 * - 실제로 충분히 빠름
 * 
 * ★ 2. 수학적 최적화 접근법
 * 
 * Digit DP (자릿수 DP):
 * - 각 자릿수별로 가능한 숫자 조합
 * - 더 복잡하지만 이론적으로 빠를 수 있음
 * - 이 문제에서는 오버엔지니어링
 * 
 * 분할 정복:
 * - 채널 번호를 구간별로 나누어 탐색
 * - 병렬 처리 가능하지만 단일 스레드에서는 이점 없음
 * 
 * ========================================================================
 * ■ 실전 코딩테스트 대비 포인트
 * ========================================================================
 * 
 * ★ 1. 브루트포스 문제 판별법
 * 
 * 브루트포스가 적합한 조건:
 * - 탐색 공간이 충분히 작음 (10^8 이하)
 * - 다른 알고리즘으로 풀기 복잡함
 * - 시간 제한이 넉넉함 (2초 이상)
 * 
 * 이 문제의 특징:
 * - 탐색 공간: 10^6 정도
 * - 그리디로는 최적해 보장 안 됨
 * - 시간 제한: 2초
 * 
 * ★ 2. 구현 시 주의사항
 * 
 * 1) 배열 인덱스 주의:
 *    - broken[10] 배열에서 broken[i]는 숫자 i가 고장났는지 표시
 * 
 * 2) 0 처리 주의:
 *    - 채널 0도 유효한 채널
 *    - 숫자 0 버튼 고장 여부 확인 필요
 * 
 * 3) 자릿수 계산:
 *    - 0의 자릿수는 1
 *    - Integer.toString(num).length() 사용 권장
 * 
 * ★ 3. 디버깅 전략
 * 
 * 작은 케이스로 검증:
 * - N = 55, 고장난 버튼 없음 → 답: 2 (55 입력)
 * - N = 55, 5 고장 → 답: 45 (+/- 만 사용)
 * - N = 100 → 답: 0
 * 
 * 경계값 테스트:
 * - N = 0, N = 500000
 * - 모든 버튼 고장, 하나만 고장
 * 
 * ========================================================================
 * ■ 확장 문제와 응용 사례
 * ========================================================================
 * 
 * ★ 1. 문제 변형
 * 
 * 2차원 리모컨 문제:
 * - (x, y) 좌표로 이동하는 문제
 * - 상하좌우 버튼과 숫자 입력 버튼
 * - 각 축별로 독립적으로 해결 후 합산
 * 
 * 다중 목표 문제:
 * - 여러 채널을 순서대로 방문
 * - 외판원 문제와 유사한 구조
 * - DP 또는 브루트포스 + 백트래킹
 * 
 * 확률적 고장 문제:
 * - 각 버튼이 확률적으로 작동
 * - 기댓값 최소화 문제
 * - 동적 계획법 필요
 * 
 * ★ 2. 실무 응용
 * 
 * UI/UX 최적화:
 * - 모바일 키패드 최적 배치
 * - 사용자 입력 패턴 분석
 * - 접근성 개선 (일부 키 사용 불가 시)
 * 
 * 로봇 제어:
 * - 로봇 팔의 관절 제어
 * - 일부 모터 고장 시 대체 경로
 * - 최소 에너지 소비 경로 계산
 * 
 * 네트워크 라우팅:
 * - 일부 노드 장애 시 우회 경로
 * - 최소 홉 카운트 라우팅
 * - 대역폭 제약 하에서 최적화
 * 
 * ★ 3. 관련 알고리즘 문제
 * 
 * BOJ 관련 문제:
 * - 1063: 킹 (브루트포스 + 시뮬레이션)
 * - 2309: 일곱 난쟁이 (브루트포스 + 조합)
 * - 14500: 테트로미노 (브루트포스 + 구현)
 * - 15686: 치킨 배달 (브루트포스 + 조합)
 * 
 * 다른 플랫폼:
 * - Codeforces: Complete search 태그 문제들
 * - AtCoder: Brute force 카테고리
 * - 프로그래머스: 완전탐색 문제들
 * 
 * ========================================================================
 * ■ 현재 구현의 특징과 최적화 여지
 * ========================================================================
 * 
 * 현재 구현의 장점:
 * 1) 명확하고 이해하기 쉬운 로직
 * 2) 모든 경우를 빠짐없이 확인
 * 3) 추가 메모리 사용 최소화
 * 4) 디버깅이 용이한 구조
 * 
 * 최적화 가능한 부분:
 * 1) 탐색 범위를 더 정교하게 설정
 * 2) 비트 연산을 활용한 유효성 검사
 * 3) 캐시 친화적인 데이터 접근 패턴
 * 4) 컴파일러 최적화 힌트 추가
 * 
 * 실무에서의 개선점:
 * 1) 입력 검증 및 예외 처리 강화
 * 2) 로깅 및 모니터링 기능 추가
 * 3) 단위 테스트 및 성능 벤치마크
 * 4) 다양한 입력 크기에 대한 성능 분석
 */
public class Main {
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt(); // 목표 채널
        int M = sc.nextInt(); // 고장난 버튼의 개수
        
        boolean[] broken = new boolean[10]; // 고장난 버튼 표시 (0~9)
        
        for (int i = 0; i < M; i++) {
            int button = sc.nextInt();
            broken[button] = true;
        }
        
        int result = findMinimumButtons(N, broken);
        System.out.println(result);
    }
    
    /**
     * 최소 버튼 누름 횟수를 찾는 함수
     * 
     * @param target 목표 채널 번호
     * @param broken 고장난 버튼 배열 (broken[i] = 숫자 i 버튼이 고장났는지)
     * @return 최소 버튼 누름 횟수
     */
    private static int findMinimumButtons(int target, boolean[] broken) {
        // 1. +/- 버튼만 사용하는 경우
        int minCost = Math.abs(target - 100);
        
        // 2. 숫자 버튼 + +/- 버튼 조합 사용
        // 탐색 범위: 0부터 999999까지 (7자리는 거의 항상 비효율적)
        for (int channel = 0; channel <= 999999; channel++) {
            // 현재 채널 번호를 만들 수 있는지 확인
            if (!canMakeChannel(channel, broken)) {
                continue;
            }
            
            // 이 채널을 만드는데 필요한 버튼 누름 횟수 계산
            int digitCount = getDigitCount(channel);
            int moveCount = Math.abs(target - channel);
            int totalCost = digitCount + moveCount;
            
            // 최솟값 갱신
            minCost = Math.min(minCost, totalCost);
        }
        
        return minCost;
    }
    
    /**
     * 주어진 채널 번호를 고장나지 않은 버튼으로 만들 수 있는지 확인
     * 
     * @param channel 확인할 채널 번호
     * @param broken 고장난 버튼 배열
     * @return 만들 수 있으면 true, 없으면 false
     */
    private static boolean canMakeChannel(int channel, boolean[] broken) {
        // 0은 특별 처리 (0 한 자리)
        if (channel == 0) {
            return !broken[0];
        }
        
        // 각 자릿수를 확인
        int temp = channel;
        while (temp > 0) {
            int digit = temp % 10;
            if (broken[digit]) {
                return false;
            }
            temp /= 10;
        }
        
        return true;
    }
    
    /**
     * 숫자의 자릿수를 계산
     * 
     * @param number 자릿수를 계산할 숫자
     * @return 자릿수
     */
    private static int getDigitCount(int number) {
        if (number == 0) {
            return 1;
        }
        
        int count = 0;
        while (number > 0) {
            count++;
            number /= 10;
        }
        
        return count;
    }
}