package p7569;

/**
 * 제목 : 토마토 (3차원) - 3D Multi-Source BFS
 * 링크 : https://www.acmicpc.net/problem/7569
 * 분류 : 그래프 이론, BFS, 3차원 배열, 시뮬레이션
 * 난이도 : Gold V
 * 
 * ========================================================================
 * ■ 문제 개요 및 핵심 개념
 * ========================================================================
 * 
 * 3차원 공간에 쌓인 토마토 상자들에서 익은 토마토가 주변의 익지 않은 토마토를 
 * 익게 만드는 확산 시뮬레이션 문제입니다. 2차원 토마토 문제(BOJ 7576)의 
 * 3차원 확장 버전으로, 멀티소스 BFS의 대표적인 응용 사례입니다.
 * 
 * ★ 문제 상황:
 * - 3차원 상자(H×N×M)에 토마토들이 보관됨
 * - 1: 익은 토마토, 0: 익지 않은 토마토, -1: 빈 공간
 * - 익은 토마토는 하루에 인접한 6방향으로 익지 않은 토마토를 1개씩 익게 함
 * - 모든 토마토가 익는 최소 일수를 구해야 함
 * 
 * ★ 3차원 좌표계:
 * - (h, r, c): 높이(층), 행(세로), 열(가로)
 * - 6방향 이동: 위/아래 + 상/하/좌/우
 * - 각 방향으로의 전파는 동시에 일어남
 * 
 * ========================================================================
 * ■ 수학적 원리와 이론적 배경
 * ========================================================================
 * 
 * ★ 1. 멀티소스 BFS (Multi-Source BFS)의 이론
 * 
 * 일반적인 BFS는 하나의 시작점에서 출발하지만, 멀티소스 BFS는 
 * 여러 시작점에서 동시에 탐색을 시작합니다.
 * 
 * 수학적 정의:
 * - S = {s₁, s₂, ..., sₖ}: 초기 익은 토마토들의 집합
 * - dist(v) = min{d(sᵢ, v) | sᵢ ∈ S}: 임의의 정점 v까지의 최단거리
 * - 여기서 d(sᵢ, v)는 sᵢ에서 v까지의 최단거리
 * 
 * ★ 2. 레벨별 확산 모델 (Level-wise Propagation)
 * 
 * 토마토 익는 과정을 그래프 이론으로 모델링:
 * - G = (V, E): 각 칸을 정점으로, 인접 관계를 간선으로 하는 그래프
 * - 가중치 없는 그래프에서 BFS는 최단거리를 보장
 * - 시간 t에서 익은 토마토 집합: Lₜ = {v | dist(v) = t}
 * 
 * ★ 3. 3차원 유클리드 공간에서의 맨하탄 거리
 * 
 * 3차원 공간에서 두 점 P₁(h₁, r₁, c₁), P₂(h₂, r₂, c₂) 사이의 맨하탄 거리:
 * d(P₁, P₂) = |h₁ - h₂| + |r₁ - r₂| + |c₁ - c₂|
 * 
 * 이는 토마토가 익는데 걸리는 최소 일수와 동일합니다.
 * 
 * ★ 4. 연결성과 도달 가능성 분석
 * 
 * 그래프 이론의 연결 성분(Connected Component) 개념 적용:
 * - 모든 토마토가 익으려면 익지 않은 토마토들이 익은 토마토와 같은 연결 성분에 있어야 함
 * - 빈 공간(-1)으로 분리된 영역은 서로 다른 연결 성분
 * - 어떤 연결 성분에 익은 토마토가 없다면 그 영역의 토마토는 영원히 익지 않음
 * 
 * ========================================================================
 * ■ 3차원 BFS 구현 방법과 최적화
 * ========================================================================
 * 
 * ★ 1. 3차원 방향 벡터 설계
 * 
 * 6방향 이동 벡터의 수학적 표현:
 * directions = {(0,0,1), (0,0,-1), (0,1,0), (0,-1,0), (1,0,0), (-1,0,0)}
 * 
 * 각각의 의미:
 * - (0,0,±1): 좌우 이동 (열 방향)
 * - (0,±1,0): 상하 이동 (행 방향)  
 * - (±1,0,0): 위아래 이동 (높이 방향)
 * 
 * ★ 2. 큐 기반 레벨 순서 탐색
 * 
 * BFS의 핵심 특성:
 * - FIFO(First In, First Out) 큐를 사용하여 레벨 순서 보장
 * - 각 레벨의 모든 노드를 처리한 후 다음 레벨로 진행
 * - 이는 토마토가 동시에 익는 특성과 완벽히 일치
 * 
 * ★ 3. 상태 공간 표현과 최적화
 * 
 * 메모리 최적화 기법:
 * 1) 별도의 visited 배열 대신 원본 배열 수정
 * 2) 0 → 1로 변경하여 방문 체크와 상태 변경을 동시에 처리
 * 3) 공간 복잡도: O(H×N×M) → 추가 메모리 없음
 * 
 * ★ 4. 조기 종료 조건
 * 
 * 최적화 전략:
 * - 익지 않은 토마토 개수를 미리 카운트
 * - BFS 진행 중 익힌 토마토 개수를 추적
 * - 모든 토마토가 익으면 즉시 종료
 * 
 * ========================================================================
 * ■ 시간/공간 복잡도 상세 분석
 * ========================================================================
 * 
 * ★ 시간 복잡도: O(H × N × M)
 * 
 * 상세 분석:
 * - 각 칸을 최대 한 번씩만 방문: O(H×N×M)
 * - 각 칸에서 6방향 확인: O(6) = O(1)
 * - 큐 연산(enqueue/dequeue): O(1)
 * - 전체 시간 복잡도: O(H×N×M×1) = O(H×N×M)
 * 
 * ★ 공간 복잡도: O(H × N × M)
 * 
 * 메모리 사용량 분석:
 * - 3차원 배열: H×N×M×4바이트 (int)
 * - 큐 최대 크기: O(H×N×M) (최악의 경우 모든 칸이 동시에 큐에 들어감)
 * - Position 객체들: 각각 16바이트 (4개 int 필드)
 * - 실제 메모리 사용량: 약 5×H×N×M×4바이트
 * 
 * ★ 실제 성능 특성
 * 
 * - 평균적으로 큐 크기는 경계면의 크기에 비례 (O(H×N + N×M + M×H))
 * - 캐시 효율성: 3차원 배열의 메모리 지역성 고려 필요
 * - 분기 예측: 조건문 최적화로 성능 향상 가능
 * 
 * ========================================================================
 * ■ 관련 알고리즘과의 비교 및 응용
 * ========================================================================
 * 
 * ★ 1. 차원별 BFS 비교
 * 
 * 1차원 BFS:
 * - 선형 배열에서 좌우 2방향 탐색
 * - 시간 복잡도: O(N)
 * - 예: 1차원 격자에서의 확산
 * 
 * 2차원 BFS:
 * - 평면에서 상하좌우 4방향 탐색  
 * - 시간 복잡도: O(N×M)
 * - 예: 미로 탐색, 섬의 개수
 * 
 * 3차원 BFS:
 * - 공간에서 6방향 탐색
 * - 시간 복잡도: O(H×N×M)
 * - 예: 3D 게임, 의료 영상 분석
 * 
 * ★ 2. 확산 모델 알고리즘 비교
 * 
 * BFS 기반 확산:
 * - 이산적 시간, 동시 확산
 * - 정확한 시뮬레이션
 * - 토마토, 바이러스 확산 등
 * 
 * DFS 기반 확산:
 * - 깊이 우선, 순차적 확산
 * - Flood fill 알고리즘
 * - 영역 채우기, 연결 성분 탐색
 * 
 * 수치해석 기반:
 * - 연속적 시간, 미분방정식
 * - 편미분방정식 해법
 * - 열 전도, 유체 역학
 * 
 * ★ 3. 실제 응용 분야
 * 
 * 의료/생명과학:
 * - 종양 확산 시뮬레이션
 * - 전염병 전파 모델링
 * - 3D 의료 영상에서 병변 추적
 * 
 * 게임 개발:
 * - 3D 공간에서의 A* 경로 탐색
 * - 실시간 전략 게임의 유닛 이동
 * - 복셀(Voxel) 기반 게임의 블록 확산
 * 
 * 컴퓨터 그래픽스:
 * - 3D 렌더링에서 레이 캐스팅
 * - 볼륨 렌더링
 * - 3D 모델링의 메시 생성
 * 
 * ========================================================================
 * ■ 실전 코딩테스트 대비 포인트
 * ========================================================================
 * 
 * ★ 1. 3차원 배열 다루기 핵심 스킬
 * 
 * 인덱싱 순서 주의:
 * - 일반적인 순서: [높이][행][열] 또는 [z][y][x]
 * - 입력 순서와 배열 인덱스 순서 일치 확인
 * - 방향 벡터와 인덱스 순서 일관성 유지
 * 
 * 경계 조건 체크:
 * - 3개 차원 모두에 대한 범위 검사 필수
 * - 단순한 실수로 인한 배열 범위 오류 빈발
 * - 체크 함수를 별도로 구현하여 재사용
 * 
 * ★ 2. 멀티소스 BFS 패턴 마스터
 * 
 * 초기화 패턴:
 * ```java
 * // 모든 시작점을 큐에 동시에 추가
 * Queue<Position> queue = new LinkedList<>();
 * for (모든 시작점) {
 *     queue.offer(new Position(시작점, 0));
 * }
 * ```
 * 
 * 레벨별 처리:
 * - 큐에 거리/시간 정보 함께 저장
 * - 각 노드에서 인접 노드로 전파 시 시간 증가
 * - 최종 결과는 최대 시간값
 * 
 * ★ 3. 입출력 최적화
 * 
 * 대용량 입력 처리:
 * - BufferedReader + StringTokenizer 조합
 * - Scanner보다 5-10배 빠른 입력 처리
 * - 메모리 제한이 까다로운 문제에서 중요
 * 
 * 출력 최적화:
 * - 단일 결과값은 System.out.println() 사용
 * - 대량 출력 시 StringBuilder 활용
 * 
 * ★ 4. 디버깅 및 검증 전략
 * 
 * 작은 케이스 테스트:
 * - 2×2×2 크기의 간단한 케이스로 로직 검증
 * - 경계 조건들을 포함한 다양한 케이스 준비
 * - 손으로 계산한 결과와 비교
 * 
 * 시각화 도구 활용:
 * - 3차원 배열 상태를 2차원으로 출력
 * - 각 레벨별로 토마토 상태 변화 추적
 * - BFS 진행 과정을 단계별로 출력
 * 
 * ========================================================================
 * ■ 확장 문제와 고급 응용
 * ========================================================================
 * 
 * ★ 1. 문제 변형 사례
 * 
 * 다중 상태 확산:
 * - 여러 종류의 토마토가 다른 속도로 익는 경우
 * - 우선순위 큐를 사용한 가중치 BFS
 * - 상태별 다른 확산 패턴
 * 
 * 장애물이 있는 확산:
 * - 일부 방향으로만 확산 가능한 경우
 * - 방향별 다른 확산 속도
 * - 동적으로 변하는 장애물
 * 
 * 역방향 추적:
 * - 특정 시점의 상태에서 초기 상태 역추적
 * - 부모 노드 정보 저장을 통한 경로 복원
 * - 최적 확산 경로 분석
 * 
 * ★ 2. 관련 고급 문제
 * 
 * BOJ 문제들:
 * - 7576: 토마토 (2차원 버전)
 * - 4179: 불! (다중 소스 + 탈출)
 * - 16234: 인구 이동 (BFS + 시뮬레이션)
 * - 17144: 미세먼지 안녕! (복잡한 확산 규칙)
 * - 14502: 연구소 (BFS + 완전탐색)
 * 
 * 국제 대회 문제:
 * - ICPC에서의 3D 그리드 문제들
 * - Codeforces의 다차원 BFS 문제들
 * - AtCoder의 그리드 시뮬레이션 문제들
 * 
 * ★ 3. 실무 프로젝트 응용
 * 
 * 머신러닝:
 * - 3D CNN에서의 특성 맵 처리
 * - 의료 영상 분할(Segmentation)
 * - 점군(Point Cloud) 데이터 처리
 * 
 * 시뮬레이션:
 * - 유한요소법(FEM) 메시 생성
 * - 물리 엔진의 충돌 감지
 * - 날씨 예측 모델의 격자 계산
 * 
 * 데이터베이스:
 * - 공간 데이터베이스의 3D 인덱싱
 * - R-tree의 3차원 확장
 * - 지리정보시스템(GIS)의 고도 데이터 처리
 * 
 * ========================================================================
 * ■ 현재 구현의 특징과 개선점
 * ========================================================================
 * 
 * 현재 구현의 장점:
 * 1) 명확한 3차원 좌표 체계 사용
 * 2) 효율적인 메모리 사용 (별도 visited 배열 없음)
 * 3) 직관적인 Position 클래스 설계
 * 4) 빠른 입력 처리 (BufferedReader)
 * 
 * 개선 가능한 점:
 * 1) 조기 종료 조건 추가로 성능 향상
 * 2) 입력 검증 및 예외 처리 강화  
 * 3) 메모리 풀링을 통한 객체 생성 비용 절약
 * 4) 비트 연산을 활용한 방향 처리 최적화
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
    
    // 6방향 이동 벡터 (위, 아래, 북, 남, 서, 동)
    static int[] dh = {-1, 1, 0, 0, 0, 0};   // 높이 방향
    static int[] dr = {0, 0, -1, 1, 0, 0};   // 행 방향  
    static int[] dc = {0, 0, 0, 0, -1, 1};   // 열 방향
    
    static int M, N, H; // 가로, 세로, 높이
    static int[][][] box; // 3차원 토마토 상자
    static Queue<Position> queue = new LinkedList<>();
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        M = Integer.parseInt(st.nextToken()); // 상자의 가로 크기
        N = Integer.parseInt(st.nextToken()); // 상자의 세로 크기  
        H = Integer.parseInt(st.nextToken()); // 상자의 높이
        
        box = new int[H][N][M];
        
        // 토마토 상태 입력 및 초기 익은 토마토 위치 저장
        for (int h = 0; h < H; h++) {
            for (int n = 0; n < N; n++) {
                st = new StringTokenizer(br.readLine());
                for (int m = 0; m < M; m++) {
                    box[h][n][m] = Integer.parseInt(st.nextToken());
                    
                    // 익은 토마토면 큐에 추가 (멀티소스 BFS를 위해)
                    if (box[h][n][m] == 1) {
                        queue.offer(new Position(h, n, m, 0));
                    }
                }
            }
        }
        
        // BFS 실행 후 결과 출력
        System.out.println(bfs());
    }
    
    /**
     * 3차원 멀티소스 BFS를 이용한 토마토 익히기
     * @return 모든 토마토가 익는데 걸리는 최소 날짜 (불가능하면 -1)
     */
    private static int bfs() {
        int maxDays = 0;
        
        while (!queue.isEmpty()) {
            Position current = queue.poll();
            int h = current.h;
            int r = current.r;
            int c = current.c;
            int days = current.days;
            
            maxDays = Math.max(maxDays, days);
            
            // 6방향으로 토마토 익히기
            for (int i = 0; i < 6; i++) {
                int nh = h + dh[i]; // 새로운 높이
                int nr = r + dr[i]; // 새로운 행
                int nc = c + dc[i]; // 새로운 열
                
                // 범위 체크 및 익지 않은 토마토인지 확인
                if (isValid(nh, nr, nc) && box[nh][nr][nc] == 0) {
                    box[nh][nr][nc] = 1; // 익은 토마토로 변경 (방문 체크 역할)
                    queue.offer(new Position(nh, nr, nc, days + 1));
                }
            }
        }
        
        // 익지 않은 토마토가 남아있는지 확인
        for (int h = 0; h < H; h++) {
            for (int n = 0; n < N; n++) {
                for (int m = 0; m < M; m++) {
                    if (box[h][n][m] == 0) {
                        return -1; // 익지 않은 토마토가 있음
                    }
                }
            }
        }
        
        return maxDays;
    }
    
    /**
     * 좌표가 유효한 범위 내에 있는지 확인
     */
    private static boolean isValid(int h, int r, int c) {
        return h >= 0 && h < H && r >= 0 && r < N && c >= 0 && c < M;
    }
    
    /**
     * 3차원 위치와 날짜 정보를 저장하는 클래스
     */
    static class Position {
        int h, r, c; // 높이, 행, 열
        int days;    // 토마토가 익은 날짜
        
        Position(int h, int r, int c, int days) {
            this.h = h;
            this.r = r;
            this.c = c;
            this.days = days;
        }
    }
}