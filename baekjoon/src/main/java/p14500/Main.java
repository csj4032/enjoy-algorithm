package p14500;

import java.util.Scanner;

/**
 * 백준 14500번: 테트로미노 (Silver 1)
 * https://www.acmicpc.net/problem/14500
 * 
 * 문제 분류: 브루트포스, 구현
 * 핵심 알고리즘: 브루트포스 + 하드코딩
 * 
 * 해결 접근 방법:
 * 1. 테트로미노의 모든 회전된 형태를 미리 계산하여 저장
 * 2. N×M 격자의 모든 위치에서 각 테트로미노 패턴을 시도
 * 3. 격자 범위를 벗어나지 않는지 확인하며 최대값 계산
 * 
 * 시간복잡도: O(N×M×19) - 19는 서로 다른 테트로미노 패턴 수
 * 공간복잡도: O(N×M) - 입력 격자 저장
 * 
 * 테트로미노 종류 (회전/대칭 포함):
 * - I: 일자형 (2가지)
 * - O: 정사각형 (1가지) 
 * - T: T자형 (4가지)
 * - S: S자형 (4가지)
 * - L: L자형 (8가지)
 * 총 19가지 패턴
 */
public class Main {

	// 테트로미노의 모든 회전/반사 형태를 상대좌표로 정의
	// 각 패턴은 4개의 칸으로 구성되며, {행변화량, 열변화량} 형태
	static int[][][] t = {
			// I 테트로미노 (일자형) - 2가지
			{{0, 0}, {0, 1}, {0, 2}, {0, 3}}, // 가로
			{{0, 0}, {1, 0}, {2, 0}, {3, 0}}, // 세로

			// T 테트로미노 (T자형) - 4가지 회전
			{{0, 0}, {0, -1}, {-1, -1}, {0, 1}}, // ㅗ
			{{0, 0}, {-1, 0}, {-1, 1}, {1, 0}}, // ㅏ
			{{0, 0}, {0, -1}, {0, 1}, {1, 1}},  // ㅜ
			{{0, 0}, {-1, 0}, {1, 0}, {1, -1}}, // ㅓ

			// L 테트로미노 - 8가지 (4회전 × 2반사)
			{{0, 0}, {0, -1}, {0, 1}, {-1, 1}}, // L 모양
			{{0, 0}, {-1, 0}, {1, 0}, {1, 1}},
			{{0, 0}, {0, -1}, {0, 1}, {1, -1}},
			{{0, 0}, {-1, 0}, {-1, -1}, {1, 0}},

			// O 테트로미노 (정사각형) - 1가지
			{{0, 0}, {0, 1}, {1, 1}, {1, 0}},

			// S 테트로미노 - 4가지 (2회전 × 2반사)
			{{0, 0}, {0, -1}, {-1, 0}, {-1, 1}}, // S 모양
			{{0, 0}, {-1, 0}, {0, 1}, {1, 1}},
			{{0, 0}, {0, 1}, {1, 0}, {1, -1}},   // Z 모양
			{{0, 0}, {0, -1}, {-1, -1}, {1, 0}},

			// 추가 L 테트로미노 패턴들
			{{0, 0}, {0, -1}, {-1, 0}, {0, 1}},
			{{0, 0}, {-1, 0}, {0, 1}, {1, 0}},
			{{0, 0}, {0, -1}, {0, 1}, {1, 0}},
			{{0, 0}, {0, -1}, {-1, 0}, {1, 0}},

			{{0, 0}, {-1, 0}, {-1, -1}, {0, 1}},
			{{0, 0}, {1, 0}, {0, 1}, {-1, 1}},
			{{0, 0}, {0, -1}, {1, 0}, {1, 1}},
			{{0, 0}, {0, -1}, {1, -1}, {-1, 0}}
	};


	public static void main(String[] args) {
		var sc = new Scanner(System.in);
		var n = sc.nextInt(); // 세로 크기
		var m = sc.nextInt(); // 가로 크기
		
		// 격자판 입력
		var board = new int[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				board[i][j] = sc.nextInt();
			}
		}

		var maxSum = 0; // 최대 합 저장
		
		// 격자의 모든 위치에서 테트로미노 패턴 시도
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				// 모든 테트로미노 패턴에 대해 확인
				for (int pattern = 0; pattern < 23; pattern++) {
					var currentSum = 0;
					var valid = true; // 현재 패턴이 유효한지 확인
					
					// 현재 패턴의 4개 칸에 대해 처리
					for (int piece = 0; piece < 4; piece++) {
						var piecePos = t[pattern][piece];
						var newRow = i + piecePos[0]; // 새로운 행 위치
						var newCol = j + piecePos[1]; // 새로운 열 위치
						
						// 격자 범위 검사
						if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
							currentSum += board[newRow][newCol];
						} else {
							valid = false; // 범위를 벗어나면 무효
							break;
						}
					}
					
					// 유효한 패턴일 때만 최대값 갱신
					if (valid) {
						maxSum = Math.max(maxSum, currentSum);
					}
				}
			}
		}
		
		System.out.println(maxSum);
	}
}
