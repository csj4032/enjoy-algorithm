package p1904;

import java.util.Scanner;

/**
 * 제목 : 01타일
 * 링크 : https://www.acmicpc.net/problem/1904
 * 분류 : 다이나믹 프로그래밍, 수학
 * 
 * === 문제 해설 ===
 * 이 문제는 "00" 타일과 "1" 타일을 사용하여 길이 N인 이진 수열을 만드는 경우의 수를 구하는 문제입니다.
 * 
 * === 수학적/이론적 배경 ===
 * 1) 피보나치 수열과의 관계:
 *    - 길이 n인 수열의 마지막이 "1"로 끝나는 경우: f(n-1)가지
 *    - 길이 n인 수열의 마지막이 "00"으로 끝나는 경우: f(n-2)가지
 *    - 따라서 f(n) = f(n-1) + f(n-2) (피보나치 점화식)
 * 
 * 2) 초기값 설정:
 *    - f(1) = 1 ("1"만 가능)
 *    - f(2) = 2 ("11", "00" 가능)
 *    - f(3) = 3 ("111", "100", "001" 가능)
 *    - f(4) = 5 ("1111", "1100", "1001", "0011", "0000" 가능)
 * 
 * === 알고리즘 설계 ===
 * 1) Bottom-up 방식의 동적 프로그래밍 사용
 * 2) 메모이제이션을 통한 중복 계산 방지
 * 3) 정적 초기화 블록으로 모든 값을 미리 계산
 * 
 * === 최적화 기법 ===
 * 1) 정적 배열 사용: 여러 테스트 케이스에서 재활용 가능
 * 2) 모듈러 연산: 오버플로우 방지 (15746으로 나눈 나머지)
 * 3) 공간 복잡도 최적화 가능 (현재는 O(N), O(1)로 개선 가능)
 * 
 * === 시간/공간 복잡도 ===
 * - 시간복잡도: O(N) - 정적 초기화 시 한 번만 실행
 * - 공간복잡도: O(N) - dp 배열 크기
 * - 실행시간: O(1) - 미리 계산된 값 조회
 * 
 * === 대안 해결법 ===
 * 1) 공간 최적화 버전: 변수 2개만 사용 (prev2, prev1)
 * 2) 행렬 거듭제곱: O(log N)으로 개선 가능 (큰 N에 대해)
 * 3) 수학적 공식: 황금비를 이용한 피보나치 일반항 (정밀도 문제 있음)
 */
//11100
//00111
//10000
//00001
//10011
//11001
//00100
//11111
//00000
public class Main {

	static int[] dp = new int[1000001];

	static {
		dp[1] = 1;
		dp[2] = 2;
		dp[3] = 3;
		dp[4] = 5;
		dp[5] = 8;

		for (int i = 6; i < 1000001; i++) {
			dp[i] = (dp[i - 2] + dp[i - 1]) % 15746;
		}
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		System.out.println(dp[n]);
	}
}